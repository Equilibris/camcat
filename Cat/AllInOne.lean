/-

+------------------------------------------+
| William SÃ¸rensen (ws423) graded ex sheet |
+------------------------------------------+

I have made the possibly poor choice of doing this assignment in lean.

This means some of the proofs (esp in Ex3) will be easier to read with an infoview.
You can view this assigment on the link below.
For the most part I have written human readable proofs (sometimes sketches),
throughout the mechanized proofs.
Unfortunately this gets much harder in Ex3.
If I deem a proof to have little to do with category theory, I will lave minimial comments.

If you struggle to use the link provided,
please simply go to https://live.lean-lang.org/ and paste this file.

This file is a combination of a bunch of different files,
some of which depend on eachother.
The original file-names have been transformed into section blocks with the same file-names.
Ex3.lean depends on both Products.lean and ExGSigma.lean.

I realise I should have preemptively asked before doing it in lean,
but sadly some family stuff happened,
and I wanted a nice pick-me-up formalization proof.
In the end this was quite an insane task to do in lean.
I believe I have learnt my lesson for this.

With all this being said I will let the rest of this example sheet speak for itself.

Link to view live:

https://live.lean-lang.org/#codez=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

-/

import Mathlib.Logic.ExistsUnique
import Mathlib.Logic.Equiv.Defs
import Mathlib.Logic.Equiv.Nat
import Mathlib.Data.Rat.Denumerable
import Mathlib.Tactic.Group
import Mathlib.Tactic.DepRewrite
import Mathlib.Algebra.Group.Defs
import Mathlib.CategoryTheory.Category.Basic
import Mathlib.CategoryTheory.Category.Cat.Terminal
import Mathlib.CategoryTheory.Closed.Cartesian
import Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts
import Mathlib.CategoryTheory.Iso
import Mathlib.LinearAlgebra.Matrix.NonsingularInverse
import Mathlib.Logic.Basic
import Mathlib.Logic.Relation
import Mathlib.Data.FinEnum

section Ex1.lean

universe u v

namespace CategoryTheory

section Ex1

-- We consider some general category ð
variable {ð : Type u} [Category ð]

-- And some objects in ð
variable {X Y Z A B C U V W L : ð}

-- Along with some morphisms
variable {f g : X â¶ Y}

-- A morphism f : X â¶ Y is a monomorphism if it is left-cancellabe.
-- Here is the definition provided by mathlib.
/--
info: constructor CategoryTheory.Mono.mk.{v, u} : â {C : Type u} [inst : Category.{v, u} C] {X Y : C} {f : X â¶ Y},
  (â {Z : C} (g h : Z â¶ X), g â« f = h â« f â g = h) â Mono f
-/
#guard_msgs in
#print Mono.mk

section Ex1_1

-- A morphism s : X â¶ Y is a *section* if:
class Section (s : X â¶ Y) where
  -- There exists some morphism
  r : Y â¶ X
  -- such that
  s_r_involution : s â« r = ð X
  -- NOTE! We write s â« r for r â s due to mathlib prefering this

instance
    -- For any
    {s : X â¶ Y}
    -- satisfying
    [hSec : Section s]
    -- it follows that it is a
    : Mono s where
  right_cancellation
      -- For some object
      {Z}
      -- and morphisms
      (g h : Z â¶ X)
      -- satisfying
      (heq : g â« s = h â« s)
      -- we are RTP
      : g = h := calc
    g = g â« ð X           := (Category.comp_id g).symm
    _ = g â« (s â« hSec.r)  := by rw [hSec.s_r_involution]
    _ = (g â« s) â« hSec.r  := (Category.assoc g s hSec.r).symm
    _ = (h â« s) â« hSec.r  := by rw [heq]
    _ = h â« (s â« hSec.r)  := (Category.assoc h s hSec.r)
    _ = h â« ð X           := by rw [hSec.s_r_involution]
    _ = h                 := (Category.comp_id h)

end Ex1_1

section Ex1_2

-- An
class Equalizer
    {L X Y : ð}
    -- is a morphism
    (l : (L â¶ X))
    -- over some pair
    (f g : (X â¶ Y))
    where
  -- whenever
  leq : l â« f = l â« g
  -- and
  uniq
    -- for every object and morphism
    {K} (k : K â¶ X)
    -- satisfying
    : k â« f = k â« g
    -- we can conclude
    â â! u : K â¶ L, u â« l = k

instance Equalizer.mono
    {L X Y : ð} {f g : X â¶ Y} {l : L â¶ X}
    (hEqz : Equalizer l f g)
    : Mono l where
  right_cancellation
      -- For some object
      {Z}
      -- and morphisms
      (u v : Z â¶ L)
      -- satisfying
      (heq : u â« l = v â« l)
      -- we are RTP
      : u = v :=

    -- We can first conclude that
    have ulfEqUlg : (u â« l) â« f = (u â« l) â« g := calc
      (u â« l) â« f
        = u â« (l â« f) := Category.assoc u l f
      _ = u â« (l â« g) := by rw [hEqz.leq]
      _ = (u â« l) â« g := (Category.assoc u l g).symm

    -- Then we can see we can instantiate hEqz.uniq
    -- using the equality we just showed.
    have â¨
      -- This gives us the morphism
      (w : Z â¶ L),
      -- satisfying
      (wlEqUl : w â« l = u â« l),
      -- which is also unique.
      -- It is just the uniqueness we need.
      (huniq : â (y : Z â¶ L), y â« l = u â« l â y = w)
    â© := hEqz.uniq (u â« l) ulfEqUlg

    calc
      u = w :=
        -- trivially, since u â« l = u â« l,
        -- we can conclude u = w.
        huniq u rfl
      w = v :=
        -- then using the assumtion heq : u â« l = v â« l
        -- we can conclude v = w.
        (huniq v heq.symm).symm

end Ex1_2

section Ex1_3

class Regular (l : L â¶ X) where
  (Y : ð)
  (f g : X â¶ Y)
  hEqz : Equalizer l f g

instance
    {s : L â¶ X}
    [hSec : Section s]
    : Regular s where
  -- We pick
  Y := X
  -- and the morphisms
  f := ð X
  g := hSec.r â« s

  -- Now it remains to show s forms an equalizer ð X and Section.r s â« s.
  hEqz := {
    -- We construct the equality proof.
    leq := (calc
      s â« ð X
        = s                 := Category.comp_id s
      _ = ð L â« s           := (Category.id_comp s).symm
      _ = (s â« hSec.r) â« s  := by rw [hSec.s_r_involution]
      _ = s â« hSec.r â« s    := Category.assoc s (Section.r s) s)
    -- Now it remains to show that s is unique.
    uniq
        {K}
        (k : K â¶ X)
        (heq : k â« ð X = k â« hSec.r â« s)
        : â! x, x â« s = k := by
      -- We begin by chancing the goal using the assumtion.
      rw [show k = k â« hSec.r â« s from (Category.comp_id _).symm.trans heq]
      clear heq
      -- Now we are RTP: â! x, x â« s = k â« Section.r s â« s
      exact â¨
        -- We pick the structure that makes the equality the easiest.
        k â« hSec.r,
        -- This collapses the equality into simply associativity
        Category.assoc k (Section.r s) s,
        -- Finally now to show the uniqueness follows cleanly
        fun y (hyeq : y â« s = k â« hSec.r â« s) => calc
          y = y â« ð L                   := (Category.comp_id y).symm
          _ = y â« (s â« hSec.r)          := by rw [hSec.s_r_involution]
          _ = (y â« s) â« hSec.r          := (Category.assoc y s hSec.r).symm
          _ = (k â« hSec.r â« s) â« hSec.r := by rw [hyeq]
          _ = k â« hSec.r â« (s â« hSec.r) := by simp only [Category.assoc]
          _ = k â« hSec.r â« ð _          := by rw [hSec.s_r_involution]
          _ = (k â« hSec.r) â« ð _        := (Category.assoc k hSec.r (ð L)).symm
          _ = k â« hSec.r                := Category.comp_id (k â« Section.r s)
      â©
  }

end Ex1_3

section Ex1_4

class Strong (m : X â¶ Y) where
  strong :
    â {U V},
    â e : U â¶ V,
    â u v,
    Epi e â e â« v = u â« m â â! d : V â¶ X, u = e â« d â§ d â« m = v

instance
    {m : X â¶ Y}
    [hReg : Regular m]
    : Strong m where
  strong {U V} e u v eepi hComm := by
    have â¨
      -- We begin by using the fact that any equalizer is a monomorphism.
      -- This will be used to right cancel m.
      (hRightCancel : â {Z : ð} (g h : Z â¶ X), g â« m = h â« m â g = h)
    â© := Equalizer.mono hReg.hEqz

    -- We expand the hypothesis into its induvidual parts.
    -- This is done to just save space.
    rcases hReg with â¨
      -- Call the object
      Z,
      -- and the morphisms
      f,
      g,
      -- We get that the expected square commutes
      mfEqMg : m â« f = m â« g,
      -- along with its uniqueness.
      -- This uniqueness will generate the needed morphism
      uniq : â {K} (k : K â¶ Y), k â« f = k â« g â â! u, u â« m = k
    â©

    -- This equality will be used to instantiate the uniqueness just above.
    -- The proof proceeds usind the left cancellation of e
    have vfEqVg : v â« f = v â« g := eepi.left_cancellation (v â« f) (v â« g) <|
      -- This proof can be made much simpler (by simp [hComm, mfEqMg]),
      -- but I keep it in the calculative format to make it more visible.
      calc
        e â« v â« f
          = (e â« v) â« f := (Category.assoc e v f).symm
        _ = (u â« m) â« f := by rw [hComm]
        _ = u â« (m â« f) := (Category.assoc _ _ _)
        _ = u â« (m â« g) := by rw [mfEqMg]
        _ = (u â« m) â« g := (Category.assoc _ _ _).symm
        _ = (e â« v) â« g := by rw [hComm]
        _ = e â« v â« g   := Category.assoc e v g

    obtain â¨
      -- We construct the morphism
      (w : V â¶ X),
      -- this syntax eliminates the equality so we are effectively rewriting with it
      (rfl : w â« m = v),
      -- We are then also given the uniqueness bellow.
      -- This will lift exactly to the uniqueness needed for the proof.
      (huniq : â x, x â« m = w â« m â x = w)
    â© := uniq v vfEqVg; clear uniq

    -- Finally, now we are RTP: â! d, u = e â« d â§ d â« m = w â« m
    refine â¨
      -- We use the constructed morphism as d
      w,
      â¨
        -- Applying the right cancellation, we're RTP: u â« m = (e â« w) â« m
        hRightCancel u (e â« w) ?_,
        -- because of the elimination (rfl : w â« m = v)
        rfl
      â©,
      -- The uniqueness lifts exactly as one would expect.
      -- We can see that hr is exactly the square we need 
      -- (thanks to the equality elimination above).
      fun y â¨_, (hr : y â« m = w â« m)â© => huniq y hr
    â©
    -- Finally, showing u â« m = (e â« w) â« m
    -- is the only thing that remains
    calc
      u â« m
        = e â« w â« m := hComm.symm
      _ = (e â« w) â« m := (Category.assoc _ _ _).symm

end Ex1_4

section Ex1_5

class Extremal (m : X â¶ Y) where
  extreme :
    â {V},
    â e : X â¶ V,
    â v : V â¶ Y,
    Epi e â e â« v = m â IsIso e

instance
    {m : X â¶ Y}
    [hStrong : Strong m]
    : Extremal m where
  extreme {V} e v eepi eeq :=
    -- We see that using the strong morphism we can construct
    have â¨
      -- the inverse morphism w
      (w : V â¶ X),
      -- along with an equation showing it forms an inverse.
      â¨(hinv : ð X = e â« w), _â©,
      _
    â© :=
      -- To do this instation we use e and the ð X morphisms.
      -- We pick e as it is the only morphism we know is Epi,
      -- and we pick ð X as it forces the equation into the form we need.
      hStrong.strong e (ð X) v
      eepi
      -- The equation we need to provide turns out to come from our assumptions.
      (eeq.trans (Category.id_comp _).symm)
    â¨
      -- We pick the inverse weve constructed
      w,
      -- and naturally the first equation is exactly what we need
      hinv.symm,
      -- we are not RTP: w â« e = ð V
      -- We note we have the equation (hinv : ð X = e â« w),
      -- using this along with the fact that e is an Epi,
      -- we can do the equational resoning.
      eepi.left_cancellation _ _ <|
        calc
          e â« w â« e
            = (e â« w) â« e := (Category.assoc e w e).symm
          _ = ð X â« e     := by rw [hinv]
          _ = e           := Category.id_comp e
          _ = e â« ð V     := (Category.comp_id e).symm
    â©

end Ex1_5

end Ex1

end CategoryTheory

end Ex1.lean

section ExGSigma.lean

universe u v

namespace List

variable {n : Nat} {A B : Type u}

structure Ï (n : Nat) where
  f : Fin n â Fin n
  bij : Function.Bijective f

-- Working with these is extremely painful as they are not what multisets expect
-- Therefore this following section justifies how these are equivilent to an inductive definition.
-- The point of this is to change the definition to talk about perms,
-- rather than using sigmas directly.
-- The definition of Perm is as follows:

/--
info: inductive List.Perm.{u} : {Î± : Type u} â List Î± â List Î± â Prop
number of parameters: 1
constructors:
List.Perm.nil : â {Î± : Type u}, [] ~ []
List.Perm.cons : â {Î± : Type u} (x : Î±) {lâ lâ : List Î±}, lâ ~ lâ â x :: lâ ~ x :: lâ
List.Perm.swap : â {Î± : Type u} (x y : Î±) (l : List Î±), y :: x :: l ~ x :: y :: l
List.Perm.trans : â {Î± : Type u} {lâ lâ lâ : List Î±}, lâ ~ lâ â lâ ~ lâ â lâ ~ lâ
-/
#guard_msgs in
#print List.Perm

-- Notably this isnt data-carrying.
-- As shown in a proof bellow, whenever you have a perm, you can construct a Ï.
-- I would almost ignore this section as it is just gruntwork and pure De Bruijn factor


-- We define sigma application as expected
def apply_sig (l : List A) (s : Ï l.length) : List A := List.ofFn (l.get â s.f)

section sigma_is_permunation

-- Any function along with a proof that it is bijective,
-- is equivilent to an equivelence from and onto iteself (A â A).
-- In lean we alias A â A as Equiv.Perm A
noncomputable def sigmaBij_equiv_EquivPerm
    : ((f : A â A) Ã' Function.Bijective f) â Equiv.Perm A where
  toFun := fun â¨f, bijâ© =>
    have eq := (Function.bijective_iff_has_inverse.mp bij)
    let inv := Classical.choose eq
    let eqs := Classical.choose_spec eq
    {
      toFun := f
      invFun := inv
      left_inv := eqs.1
      right_inv := eqs.2
    }
  invFun := fun â¨f, inv, ha, hbâ© =>
    â¨f, Function.bijective_iff_has_inverse.mpr â¨inv, ha, hbâ©â©
  left_inv := by
    rintro â¨x, bijâ©
    simp
  right_inv := by
    rintro â¨f, inv, ha, hbâ©
    simp
    generalize_proofs p
    funext v 
    obtain â¨a, rfl, -â© := Function.Bijective.existsUnique
      (Function.bijective_iff_has_inverse.mpr p) v
    have â¨hl, _â© := Classical.choose_spec p
    rw [ha, hl]

def Ï.unfold : Ï n â ((f : Fin n â Fin n) Ã' Function.Bijective f) := {
  toFun := fun â¨f,bijâ© => â¨f, bijâ©
  invFun := fun â¨f,bijâ© => â¨f, bijâ©
}

noncomputable def Ï.isEquivPerm {n} : Ï n â Equiv.Perm (Fin n) :=
  Ï.unfold.trans sigmaBij_equiv_EquivPerm

-- supprisingly easy theorem using the a proof from mathlib.
theorem apply_sig_Perm {l : List A} {s : Ï _} : List.Perm (l.apply_sig s) l := by
  dsimp [List.apply_sig]
  let x := Ï.isEquivPerm.toFun s
  have : s.f = x := rfl
  rw [this]
  have eq := Equiv.Perm.ofFn_comp_perm x (List.get l)
  rw [List.ofFn_get] at eq
  exact eq

@[simp]
theorem apply_sig_length {l : List A} {s : Ï _} : (l.apply_sig s).length = l.length :=
  List.Perm.length_eq List.apply_sig_Perm

-- This is in mathlib, I actually pushed it there
-- The problem is my mathlib is too out of date so i copied it here.
theorem dcongr_heq
    {Î±â Î±â : Sort u}
    {Î²â : Î±â â Sort v} {Î²â : Î±â â Sort v}
    {fâ : â a, Î²â a} {fâ : â a, Î²â a}
    {aâ : Î±â} {aâ : Î±â}
    (hargs : aâ â aâ)
    (ht : â tâ tâ, tâ â tâ â Î²â tâ = Î²â tâ)
    (hf : Î±â = Î±â â Î²â â Î²â â fâ â fâ) :
    fâ aâ â fâ aâ := by
  cases hargs
  cases funext fun v => ht v v .rfl
  cases hf rfl .rfl
  rfl

-- This proof could be made constructive by transforming Perm to reside in Type
-- This is by far the most gruntworky section component of the proof.
theorem Perm_apply_sig : {lâ lâ : List A} â lâ.Perm lâ â â s, lâ.apply_sig s = lâ := by
  intro lâ lâ perm
  induction perm
  Â· exact â¨â¨_, Function.bijective_idâ©, rflâ©
  case cons ih =>
    have â¨â¨f, â¨finj, fsurâ©â©, feqâ© := ih
    exact â¨
      â¨
        (fun
          | Fin.mk 0 h => Fin.mk 0 h
          | Fin.mk (n+1) h => Fin.succ (f â¨n, Nat.succ_lt_succ_iff.mp hâ©)),
        â¨
          fun a b h => by
            dsimp at h
            split at h
            <;> split at h
            <;> simp_all [Fin.succ]
            Â· rename_i nâ hnâ _ nâ hnâ
              have := finj (Fin.eq_of_val_eq h)
              simp_all
            ,
          fun
            | â¨0, hâ© => â¨â¨0, hâ©, rflâ©
            | â¨n+1, hâ© => by
              have â¨w, hâ© := fsur â¨n, Nat.succ_lt_succ_iff.mp hâ©
              use (.succ w)
              simp [Fin.succ, h]
        â©
      â©,
      by
        rw [âfeq]
        simp only [List.apply_sig, List.length_cons, Fin.zero_eta, List.ofFn_succ,
          Function.comp_apply, List.get_eq_getElem, List.cons.injEq, List.ofFn_inj]
        constructor
        Â· rfl
        Â· rfl
    â©
  case swap =>
    exact â¨
      â¨
        fun 
          | â¨0,_â© => â¨1, by simpâ©
          | â¨1,_â© => â¨0, by simpâ©
          | x@â¨n+2,_â© => x,
        â¨
          fun a b h => by
            dsimp at h
            split at h
            <;> split at h
            <;> simp_all,
          fun
            | â¨0,_â© => â¨â¨1, by simpâ©, rflâ©
            | â¨1,_â© => â¨â¨0, by simpâ©, rflâ©
            | â¨n+2, hâ© => â¨â¨n+2, hâ©, rflâ©,
        â©,
      â©,
      by
        simp only [List.apply_sig, List.length_cons, Fin.mk_one, Fin.zero_eta, List.ofFn_succ,
          Function.comp_apply, List.get_eq_getElem, Fin.succ, Fin.coe_ofNat_eq_mod, Nat.zero_mod,
          zero_add, Nat.succ_eq_add_one, List.getElem_cons_succ, List.ofFn_getElem, List.cons.injEq,
          and_true]
        refine â¨rfl, rflâ©,
    â©
  case trans x y z pâ _ iha ihb=>
  /- | x, z, .trans (lâ := y) pâ pâ =>  -/
    have â¨â¨f, fbijâ©, hEqfâ© := iha
    have â¨â¨g, gbijâ©, hEqgâ© := ihb
    have := List.Perm.length_eq pâ
    exact â¨
      â¨
        f â (this â¸ g),
        Function.Bijective.comp fbij (by grind)
      â©,
      by
        simp only [List.apply_sig] at hEqf hEqg â¢
        rw [âList.ofFn_get z] at hEqg â¢
        rw [âList.ofFn_get y] at hEqf
        have hEqg' := List.ofFn_inj'.mp hEqg
        have hEqf' := List.ofFn_inj'.mp hEqf
        clear *-hEqg' hEqf'
        apply List.ofFn_inj'.mpr
        simp only [Sigma.mk.injEq] at hEqg' hEqf' â¢
        refine â¨by simp_all, ?_â©
        change (_ â f) â _ â _
        rw! [hEqf'.2, âhEqg'.2]
        simp only [heq_cast_iff_heq]
        apply dcongr_heq
        Â· exact eqRec_heq_self (motive := fun x h â¦ Fin x â Fin x) g (Eq.symm this)
        Â· simp_all
        rintro - -
        apply dcongr_heq
        Â· exact cast_heq (Eq.symm (type_eq_of_heq hEqf'.right)) y.get
        Â· simp_all
        rintro - -
        congr!
    â©

theorem ex_sigma_perm {lâ lâ : List A} (h : â s, lâ.apply_sig s = lâ) : lâ.Perm lâ := by
  rcases h with â¨s, rflâ©
  exact Perm.symm apply_sig_Perm

-- Finally we can show my notion is equivilent to the one given in the task
theorem sigma_is_permunation
    {P : List A â List A â Prop}
    : (â l : List A, â Ï : Ï l.length, P l (l.apply_sig Ï))
    â (â lâ lâ, lâ.Perm lâ â P lâ lâ) where
  mp  h lâ lâ hperm := by
    obtain â¨s, rflâ© := List.Perm_apply_sig hperm
    exact h lâ s
  mpr h l Ï :=
    h l (l.apply_sig Ï) <| List.Perm.symm List.apply_sig_Perm

end sigma_is_permunation

end List

end ExGSigma.lean

section Ex2.lean

universe u v

namespace CategoryTheory

section Ex2

variable {n : Nat} {A B : Type u}

-- This question discusses vectors Aâ¿ of the form.
#check Fin n â A
-- We can show A* is equivilent to lists
-- Therefore I deam it justifiable to use List A in place of the Sigma (Fin Â· â A) definition.

instance : Equiv ((n : Nat) Ã (Fin n â A)) (List A) where
  toFun  := fun â¨_, vâ© => List.ofFn v
  invFun l := â¨l.length, l.getâ©
  left_inv := by
    rintro â¨l, fâ©
    ext
    Â· simp only [List.length_ofFn]
    Â· simp only
      apply Function.hfunext
      Â· simp
      Â· intro a a' heq
        simp only [List.get_eq_getElem, List.getElem_ofFn, heq_eq_eq]
        congr
        simp
  right_inv l := by simp

instance : Monoid (List A) where
  one := []
  mul := List.append

  mul_assoc := List.append_assoc
  one_mul := List.nil_append
  mul_one := List.append_nil

-- Sing(leton) is equally defined.
/--
info: protected def List.singleton.{u} : {Î± : Type u} â Î± â List Î± :=
fun {Î±} a â¦ [a]
-/
#guard_msgs in
#print List.singleton

-- Flat is also defined
/-- info: List.flatten.{u} {Î± : Type u} : List (List Î±) â List Î± -/
#guard_msgs in
#check List.flatten
-- satsifying the desired equation.
/--
info: List.flatten_cons.{u_1} {Î±â : Type u_1} {l : List Î±â} {L : List (List Î±â)} : (l :: L).flatten = l ++ L.flatten
-/
#guard_msgs in
#check List.flatten_cons

-- In ExGSigma.lean I now go on to prove that Permutations are equivilent Ï.
-- This is why in this task I use Permutation instead.
-- The reasoning for this is the signature of Quot.lift for permutations.

#check (Quotient.lift
    : (f : List A â B)
    â (â (a b : List A), a.Perm b â f a = f b)
    â Multiset A â B)

-- This means a C*Alg can lift exactly to a function from Multisets to their result.
-- This makes the proof super clean.

-- We need this slighly cute lemma for the end of the proof
theorem Multiset.sum_sing_map
    (v : List A)
    : (List.map (fun X_1 â¦ {X_1}) v).sum = Multiset.ofList v := by
  induction v
  Â· rfl
  case cons ih => simp [ih]

-- With that out of the way I will continue through the next sections

structure CommStarAlg A where
  Î± : List A â A

  sing      : Î± â List.singleton = id
  map_flat  : Î± â List.map Î± = Î± â List.flatten

  -- This is the changed definition because of setoid nonsense
  apply_sig : â lâ lâ, lâ.Perm lâ â Î± lâ = Î± lâ

-- I believe there exists a unique isomorphism between CommStarAlg and Abel

structure CommStarHom (a : CommStarAlg A) (b : CommStarAlg B) where
  h : A â B
  heq : b.Î± â List.map h = h â a.Î±

instance {a : CommStarAlg A} {b : CommStarAlg B}
    : CoeFun (CommStarHom a b) (fun _ => A â B) where
  coe := CommStarHom.h

structure CommStarAlgAt (X : Type u) where
  A : Type _
  a : CommStarAlg A
  f : X â A

variable {X : Type _}

instance : CoeFun (CommStarAlgAt X) (fun v => X â v.A) where
  coe := CommStarAlgAt.f

structure CommStarHomAt (a b : CommStarAlgAt X) extends CommStarHom a.a b.a where
  hAtEq : h â a = b

namespace CommStarAlgAt

-- We can now define the category we want

instance : Category (CommStarAlgAt X) where
  Hom := CommStarHomAt
  id X := {
    h := id
    heq := by simp only [List.map_id_fun, CompTriple.comp_eq]
    hAtEq := rfl
  }
  comp {X Y Z} A B := {
    h := B.h â A.h
    heq := calc
      Z.a.Î± â List.map (B.h â A.h)
        = (Z.a.Î± â List.map B.h) â List.map A.h := by rw [âList.map_comp_map]; rfl
      _ = B.h â (Y.a.Î± â List.map A.h)          := by rw [B.heq]; rfl
      _ = (B.h â A.h) â X.a.Î±                   := by rw [A.heq]; rfl
    hAtEq := calc
      B.h â (A.h â X.f)
        = B.h â Y.f     := by rw [A.hAtEq]
      _ = Z.f           := B.hAtEq
  }
  -- comp_id, id_comp, and assoc are proven for free.
  -- and as they seem to be given in the defn I wont bother redoing it by hand.

-- We define a function toMultisetFn,
-- this follows exactly from the defn of the C*Alg(X)
-- This is also where the fact that i picked using List.Perm over Ï comes in.
-- All the work done above can be justified by simply writing this function.
def toMultisetFn (Y : CommStarAlgAt X)
    : Multiset Y.A â Y.A :=
  Quotient.lift Y.a.Î± Y.a.apply_sig

-- The function distributes in interesting ways.
theorem toMultisetFn_distrib
    {Y : CommStarAlgAt X}
    {a b : Multiset _}
    : Y.toMultisetFn (a + b)
    = Y.a.Î± [Y.toMultisetFn a, Y.toMultisetFn b] := by
  induction a using Quotient.ind; induction b using Quotient.ind; rename_i a b
  symm; calc
    (Y.a.Î± â List.map Y.a.Î±) [a, b]
      = (Y.a.Î± â List.flatten) [a, b] := by rw [Y.a.map_flat]
    _ = Y.a.Î± (a ++ b)                := by simp

-- This is also a general lemma which will be very useful later on.
theorem distrub_tail
    {Y : CommStarAlgAt X}
    {a b}
    : Y.a.Î± [a, Y.a.Î± b] = Y.a.Î± (a :: b) := calc
    Y.a.Î± [id a, Y.a.Î± b]
      = Y.a.Î± [(Y.a.Î± â .singleton) a, Y.a.Î± b] := by rw [âY.a.sing]
    _ = (Y.a.Î± â .map Y.a.Î±) [.singleton a, b]  := rfl
    _ = (Y.a.Î± â .flatten) [.singleton a, b]    := by rw [Y.a.map_flat]
    _ = Y.a.Î± (a :: b)                          := by simp [List.singleton]
  -- The last step doesnt really have anything to do with category theory,
  -- so I'll just let `simp` solve it

-- Here we can finally define the initial object
-- It is analgous how we made the free monoid from a list,
-- we make the free abelian monoid from a Multiset.
-- Multisets are lists quotient by the permutation setoid (List.Perm).
-- Multisets are both functors and (abelian) monoids,
-- which are the two structures we will use in this proof.

def init : CommStarAlgAt X where
  A := Multiset X
  a := {
    -- The monoid on Multisets is concatonation lifted from Lists.
    -- We then pick List.sum as our function as it has the property we want
    --   List.sum [a,b,c] = a + b + c = â¦a ++ b ++ câ§ .
    -- The square brackets here are refering to the content of the quotient.
    Î± := List.sum
    sing := funext fun v => by simp [List.singleton, List.sum]
    map_flat := funext fun v => by simp
    -- We get apply_sig for free as multisets are abelian.
    apply_sig lâ lâ := List.Perm.sum_eq
  }
  -- f is actually just sing lifted which is cute
  f := fun X => {X}

-- To prove an object is initial it suffices to:
-- Construct a morphism from the â¥ to any other object,
-- and to show this morphism is unique.
-- The function Limits.IsInitial.ofUniqueHom does exactly this:
-- (NOTE: This isnt definition because initials are given as Limits)

/--
info: CategoryTheory.Limits.IsInitial.ofUniqueHom.{vâ, uâ} {C : Type uâ} [Category.{vâ, uâ} C] {X : C} (h : (Y : C) â X â¶ Y)
  (uniq : â (Y : C) (m : X â¶ Y), m = h Y) : Limits.IsInitial X
-/
#guard_msgs in
#check Limits.IsInitial.ofUniqueHom 

def isInit X : Limits.IsInitial (CommStarAlgAt.init (X := X)) :=
  .ofUniqueHom
    (fun Y => {
      -- We construct the morphism using the toMultisetFn function.
      -- This distributes with Y.f nicely as shown above.
      h (m : Multiset X) := Y.toMultisetFn (Multiset.map Y.f m)
      -- We are now RTP : (Y.a.Î± â List.map fun m â¦ Y.toMultisetFn (Multiset.map Y.f m))
      --      = (fun m â¦ Y.toMultisetFn (Multiset.map Y.f m)) â init.a.Î±
      -- This follows from the distrubution lemmas given above.
      heq := funext fun (v : List (Multiset _)) => by
        dsimp [init]
        induction v
        Â· rfl
        case cons hd tl ih =>
          simp only [List.map_cons, List.sum_cons, Multiset.map_add]
          rw [toMultisetFn_distrib, âih]
          exact distrub_tail.symm
      -- Next we are RTP: (fun m â¦ Y.toMultisetFn (Multiset.map Y.f m)) â init.f = Y.f
      hAtEq := funext fun v => by
        -- To show it is unique we can use sing thanks to nice defeqs from lean.
        change (Y.a.Î± â List.singleton) _= _
        rw [Y.a.sing, id]
    })
    fun Y â¨
        â¨
          m,
          (hmEq : Y.a.Î± â List.map m = m â init.a.Î±)
        â©,
        (mSigEqf : (m â fun X => ({X} : Multiset _)) = Y.f)
      â© => by
      dsimp [init] at mSigEqf hmEq â¢
      refine (CommStarHomAt.mk.injEq _ _ _ _).mpr 
        <| (CommStarHom.mk.injEq _ _ _ _).mpr 
        <| funext fun v => Eq.symm ?_
      -- Shwoing that the function is unique is quite nice to do actually
      -- We are RTP: m v = Y.toMultisetFn (Multiset.map Y.f v)
      induction v using Quotient.ind
      rename_i v
      calc
        Y.a.Î± (List.map Y.f v)
          = Y.a.Î± (List.map Y.f v)                         := rfl
        _ = Y.a.Î± (List.map (m â _) v)                     := by rw [mSigEqf]
        _ = Y.a.Î± (List.map m (List.map _ v))              := by rw [List.map_map]
        _ = (Y.a.Î± â List.map m) (List.map _ v)            := rfl
        _ = (m â _) (List.map _ v)                         := by rw [hmEq]
        _ = m (v.map (fun X_1 â¦ ({X_1} : Multiset _))).sum := by rfl
        _ = m (Multiset.ofList v)                          := by rw [Multiset.sum_sing_map v]
        _ = m â¦vâ§                                          := rfl

-- Sanity check the proof doesnt depend on sorryAx.
/--
info: 'CategoryTheory.CommStarAlgAt.isInit' depends on axioms: [propext, Classical.choice, Quot.sound]
-/
#guard_msgs in
#print axioms isInit

instance {X : Type u} : Limits.HasInitial (CommStarAlgAt.{u, u} X) :=
  Limits.IsInitial.hasInitial (isInit X)

end CommStarAlgAt

end Ex2

end CategoryTheory

end Ex2.lean

section Product.lean

namespace CategoryTheory.Limits

universe u

variable
    {ð : Type u}
    [Category ð]
    {U V W X Y Z P T : ð}

section prod

variable 
    (fst : P â¶ X)
    (snd : P â¶ Y)

def IsBinaryProduct :=
  IsLimit (BinaryFan.mk fst snd)

def IsBinaryProduct.ofUniqueHom {fst snd}
    (lift : {T : ð} â (T â¶ X) â (T â¶ Y) â (T â¶ P))
    (hlâ : â {T} (f : T â¶ X) (g : T â¶ Y), lift f g â« fst = f)
    (hlâ : â {T} (f : T â¶ X) (g : T â¶ Y), lift f g â« snd = g)
    (uniq : â {T} (f : T â¶ X) (g : T â¶ Y) (m : T â¶ P), m â« fst = f â m â« snd = g â m = lift f g)
    : IsBinaryProduct fst snd :=
  BinaryFan.IsLimit.mk _ lift hlâ hlâ uniq

theorem IsBinaryProduct.hasBinaryProduct (h : IsBinaryProduct fst snd) : HasBinaryProduct X Y :=
  â¨â¨{ cone := BinaryFan.mk fst snd, isLimit := h }â©â©

variable {fst snd}

def IsBinaryProduct.lift
    (h : IsBinaryProduct fst snd)
    {T : ð}
    (f : T â¶ X)
    (g : T â¶ Y)
    : T â¶ P :=
  IsLimit.lift h { pt := T, Ï := mapPair f g}

@[simp]
theorem IsBinaryProduct.lift_fst
    (h : IsBinaryProduct fst snd)
    (f : T â¶ X)
    (g : T â¶ Y)
    : h.lift f g â« fst = f :=
  h.fac { pt := T, Ï := mapPair f g } (.mk .left)

@[simp]
theorem IsBinaryProduct.lift_snd
    (h : IsBinaryProduct fst snd)
    (f : T â¶ X)
    (g : T â¶ Y)
    : h.lift f g â« snd = g :=
  h.fac { pt := T, Ï := mapPair f g } (.mk .right)

theorem IsBinaryProduct.uniq
    (h : IsBinaryProduct fst snd)
    (f : T â¶ X)
    (g : T â¶ Y)
    (m : T â¶ P)
    (hf : m â« fst = f)
    (hg : m â« snd = g)
    : m = h.lift f g :=
  IsLimit.uniq h { pt := T, Ï := mapPair f g } m fun
    | .mk .left => hf
    | .mk .right => hg

def IsBinaryProduct.map
    (fst : P â¶ X)
    (snd : P â¶ Y)
    {P' X' Y' : ð}
    {fst' : P' â¶ X'}
    {snd' : P' â¶ Y'}
    (hg : IsBinaryProduct fst' snd')
    (f : X â¶ X')
    (g : Y â¶ Y')
    : P â¶ P' :=
  hg.lift (fst â« f) (snd â« g)

theorem IsBinaryProduct.hom_ext
    (h : IsBinaryProduct fst snd)
    {f g : T â¶ P}
    (hl : f â« fst = g â« fst)
    (hr : f â« snd = g â« snd)
    : f = g :=
  BinaryFan.IsLimit.hom_ext h hl hr

@[simp]
theorem IsBinaryProduct.lift_fst_snd
    (h : IsBinaryProduct fst snd)
    : h.lift fst snd = ð _ :=
  h.hom_ext
    ((h.lift_fst _ _).trans (Category.id_comp _).symm)
    ((h.lift_snd _ _).trans (Category.id_comp _).symm)

@[simp]
theorem IsBinaryProduct.lift_comp 
    (h : IsBinaryProduct fst snd)
    (f : T â¶ X)
    (g : T â¶ Y)
    (v : V â¶ T)
    : v â« h.lift f g = h.lift (v â« f) (v â« g) :=
  h.hom_ext
    (by simp)
    (by simp)

def IsBinaryProduct.iso
    {X Y Pâ Pâ : ð}
    {fstâ : Pâ â¶ X} {sndâ : Pâ â¶ Y}
    {fstâ : Pâ â¶ X} {sndâ : Pâ â¶ Y}
    (hâ : IsBinaryProduct fstâ sndâ)
    (hâ : IsBinaryProduct fstâ sndâ)
    : Pâ â Pâ where
  hom := hâ.lift fstâ sndâ
  inv := hâ.lift fstâ sndâ
  hom_inv_id := hom_ext hâ (by simp) (by simp)
  inv_hom_id := hom_ext hâ (by simp) (by simp)

noncomputable def productIsBinaryProduct [HasBinaryProduct X Y]
    : IsBinaryProduct (prod.fst : X â¨¯ Y â¶ X) prod.snd :=
  prodIsProd X Y

end prod

section coprod

variable
    (inl : X â¶ P)
    (inr : Y â¶ P)

def IsBinaryCoproduct :=
  IsColimit (BinaryCofan.mk inl inr)

def IsBinaryCoproduct.ofUniqueHom {inl inr}
    (desc : {T : _} â (X â¶ T) â (Y â¶ T) â (P â¶ T))
    (hdâ : â {T : _} (f : X â¶ T) (g : Y â¶ T), inl â« desc f g = f)
    (hdâ : â {T : _} (f : X â¶ T) (g : Y â¶ T), inr â« desc f g = g)
    (uniq : â {T : _} (f : X â¶ T) (g : Y â¶ T) (m : P â¶ T), inl â« m = f â inr â« m = g â m = desc f g)
    : IsBinaryCoproduct inl inr :=
  BinaryCofan.IsColimit.mk _ desc  hdâ hdâ uniq

theorem IsBinaryCoproduct.hasBinaryCoproduct
    (h : IsBinaryCoproduct inl inr)
    : HasBinaryCoproduct X Y :=
  â¨â¨{ cocone := BinaryCofan.mk inl inr, isColimit := h }â©â©

variable {inl inr}

def IsBinaryCoproduct.desc
    (h : IsBinaryCoproduct inl inr)
    {T : ð}
    (f : X â¶ T)
    (g : Y â¶ T)
    : P â¶ T :=
  IsColimit.desc h { pt := T, Î¹ := mapPair f g }

@[simp]
theorem IsBinaryCoproduct.inl_desc
    (h : IsBinaryCoproduct inl inr)
    (f : X â¶ T)
    (g : Y â¶ T)
    : inl â« h.desc f g = f :=
  h.fac { pt := T, Î¹ := mapPair f g } (.mk .left)

@[simp]
theorem IsBinaryCoproduct.inr_desc
    (h : IsBinaryCoproduct inl inr)
    (f : X â¶ T)
    (g : Y â¶ T)
    : inr â« h.desc f g = g :=
  h.fac { pt := T, Î¹ := mapPair f g } (.mk .right)

theorem IsBinaryCoproduct.uniq
    (h : IsBinaryCoproduct inl inr)
    (f : X â¶ T)
    (g : Y â¶ T)
    (m : P â¶ T)
    (hf : inl â« m = f)
    (hg : inr â« m = g)
    : m = h.desc f g :=
  IsColimit.uniq h { pt := T, Î¹ := mapPair f g } m fun
    | .mk .left => hf
    | .mk .right => hg

def IsBinaryCoproduct.hom_ext
    (h : IsBinaryCoproduct inl inr)
    {f g : P â¶ T}
    (hl : inl â« f = inl â« g)
    (hr : inr â« f = inr â« g)
    : f = g :=
  BinaryCofan.IsColimit.hom_ext h hl hr

@[simp]
theorem IsBinaryCoproduct.inl_inr_desc
    (h : IsBinaryCoproduct inl inr)
    : h.desc inl inr = ð _ :=
  h.hom_ext
    ((h.inl_desc _ _).trans (Category.comp_id _).symm)
    ((h.inr_desc _ _).trans (Category.comp_id _).symm)

@[simp]
theorem IsBinaryCoproduct.desc_comp
    (h : IsBinaryCoproduct inl inr)
    (f : X â¶ T)
    (g : Y â¶ T)
    (v : T â¶ V)
    : h.desc f g â« v = h.desc (f â« v) (g â« v) :=
  h.hom_ext
    (by rw [â Category.assoc]; simp)
    (by rw [â Category.assoc]; simp)

def IsBinaryCoproduct.iso
    {X Y Pâ Pâ : ð}
    {inlâ : X â¶ Pâ} {inrâ : Y â¶ Pâ}
    {inlâ : X â¶ Pâ} {inrâ : Y â¶ Pâ}
    (hâ : IsBinaryCoproduct inlâ inrâ)
    (hâ : IsBinaryCoproduct inlâ inrâ)
    : Pâ â Pâ where
  hom := hâ.desc inlâ inrâ
  inv := hâ.desc inlâ inrâ
  hom_inv_id := hom_ext hâ (by simp) (by simp)
  inv_hom_id := hom_ext hâ (by simp) (by simp)

noncomputable def coproductIsBinaryCoproduct [HasBinaryCoproduct X Y]
    : IsBinaryCoproduct (coprod.inl : X â¶ X â¨¿ Y) coprod.inr :=
  coprodIsCoprod X Y

noncomputable def coprod_homset_equiv
    [HasBinaryCoproduct X Y] {Z : ð}
    : ((X â¨¿ Y) â¶ Z) â ((X â¶ Z) Ã (Y â¶ Z)) where
  toFun   v := â¨coprod.inl â« v, coprod.inr â« vâ©
  invFun  v := coprod.desc v.1 v.2
  left_inv a := by simp [âcoprod.desc_comp]
  right_inv a := by simp

end coprod

end CategoryTheory.Limits

end Product.lean

section Ex3.lean

universe u v

namespace CategoryTheory

variable {A B C : Type _}

/-
  This file is not remotely as clean as Ex1 or Ex2.
  This is mainly seen in the large usage of `simp`.
  `simp` is an automatic simplification tactic that tries to normalise.
  Since I have resorted to developing my own theory (fin_preimage) to construct comp,
  I need to use a lot of simp lemmas from mathlib.
-/

section lemmas

-- This section mainly concerns a collection of lemmas that are needed for the later proofs.
-- They could (and will be after this assessment) be parts of mathlib.
-- All this is basically just noise.
-- Feel free to skip 250 lines down.

theorem fin_cast_linv {n m} (p : n = m) : Function.LeftInverse (Fin.cast p.symm) (Fin.cast p) :=
  fun _ => rfl
theorem fin_cast_rinv {n m} (p : n = m) : Function.RightInverse (Fin.cast p.symm) (Fin.cast p) :=
  fun _ => rfl

theorem fin_cast_id {n m} (p : n = m) : Fin.cast p â Fin.cast p.symm = id := rfl

theorem bij_f_cast {n m} {p : n = m} : Function.Bijective (Fin.cast p) := by
  constructor
  Â· exact Fin.cast_injective p
  Â· intro a
    use (Fin.cast p.symm a)
    rw [Fin.cast_trans, Fin.cast_eq_self]

@[simp]
theorem filterMap_add
    {a b : Multiset A}
    {f : A â Option B}
    : ((a + b).filterMap f) = (a.filterMap f + b.filterMap f) := by 
  induction a using Quot.ind; rename_i a
  induction b using Quot.ind; rename_i b
  simp
@[simp]
theorem filterMap_none
    {ms : Multiset A}
    : Multiset.filterMap (fun _ â¦ none) ms = ({} : Multiset B) := by
  induction ms using Quot.ind; rename_i ms
  simp

@[simp]
theorem map_singleton_flatten : {a : List A} â (List.map List.singleton a).flatten = a
  | [] => rfl
  | hd :: tl => by
    change hd :: (List.map List.singleton tl).flatten = hd :: tl
    rw [map_singleton_flatten]

@[simp]
theorem map_singleton_sum {a : Multiset A} : (a.map ({Â·})).sum = a := by
  induction a using Quot.ind; rename_i a
  simp
  induction a
  Â· rfl
  Â· simp_all

@[simp]
theorem multiset_map_some {f : A â B} {ms : Multiset (Multiset A)} :
    Multiset.map f ms.sum = (ms.map (Multiset.map f)).sum := by
  induction ms using Quot.ind;rename_i ms
  simp only [Multiset.quot_mk_to_coe'', Multiset.sum_coe, Multiset.map_coe]
  induction ms
  Â· rfl
  case cons hd tl ih => simpa

@[simp]
theorem multiset_map_all {a : List A}
    : (Multiset.map a.get Fintype.elems.val)
    = Multiset.ofList a := by
  induction a
  Â· rfl
  case cons hd tl ih =>
    have : (Fintype.elems.val : Multiset (Fin (hd :: tl).length)) = 
      â¨0, by simpâ© ::â (Fintype.elems.val.map Fin.succ) := by
      refine (Multiset.Nodup.ext ?_ ?_).mpr ?_
      Â· exact Fintype.elems.nodup
      Â· simp only [List.length_cons, Fin.zero_eta, Multiset.nodup_cons, Multiset.mem_map,
          Finset.mem_val, Fin.succ_ne_zero, and_false, exists_false, not_false_eq_true, true_and]
        exact
          (Multiset.nodup_map_iff_of_injective <| Fin.succ_injective _).mpr
            Fintype.elems.nodup
      rintro (_|_)
      <;> simp [Fintype.complete]
    rw [this]
    simp only [Fin.zero_eta, List.length_cons, Multiset.map_cons, Multiset.map_map,
      Function.comp_apply]
    change hd ::â Multiset.map tl.get _ = _
    rw [ih]
    simp

@[simp]
theorem multiset_map_all' {a : List A}
    : (Multiset.map (fun x â¦ a[âx]) (Fintype.elems.val : Multiset <| Fin a.length))
    = Multiset.ofList a :=
  multiset_map_all

@[simp]
theorem Perm_ofList_toList {a : List A} : a.Perm (Multiset.ofList a).toList :=
  Multiset.coe_eq_coe.mp <| (Multiset.coe_toList _).symm

instance finite_of_finite_powerset : Finite (A â Bool) â Finite A := by
  contrapose
  simp only [not_finite_iff_infinite]
  exact fun a â¦ Function.infinite_of_left

theorem multiset_finite : Finite (Multiset A) â IsEmpty A := by
  contrapose
  simp only [not_isEmpty_iff, not_finite_iff_infinite, Nonempty.forall]
  intro a
  apply Infinite.of_injective (Î² := Nat) (Multiset.replicate Â· a)
  intro a b h
  simp only [Multiset.eq_replicate, Multiset.card_replicate] at h
  exact h.1

theorem mem_sum {a}
    {ls : List (Multiset B)}
    (h : a â ls.sum) : â idx : Fin _, a â ls[idx] := by
  induction ls
  Â· simp at h
  case cons hd tl ih =>
    simp only [List.sum_cons, Multiset.mem_add] at h
    rcases h with (h|h)
    Â· exact â¨â¨0, by simpâ©, hâ©
    Â· specialize ih h
      rcases ih with â¨idx, pâ©
      refine â¨â¨idx + 1, by simpâ©, pâ©

theorem nodup_disj
    [Fintype A]
    {s : A â Multiset B}
    (hNd : â x, (s x).Nodup)
    (h : â a b, a â  b â Disjoint (s a) (s b)) : (â x, s x).Nodup := by
  change (Multiset.map s Finset.univ.val).sum.Nodup
  rcases Finset.univ with â¨elems, ndâ©
  induction elems using Quot.ind; rename_i elems
  simp only [Multiset.quot_mk_to_coe'', Multiset.coe_nodup, Multiset.map_coe,
    Multiset.sum_coe] at nd â¢
  induction elems
  Â· simp
  case cons hd tl ih =>
    simp at nd â¢
    specialize ih nd.2
    apply (Multiset.Nodup.add_iff _ ih).mpr
    Â· apply Multiset.disjoint_left.mpr
      intro a mema memb
      have â¨idx, membâ© := mem_sum memb
      simp only [Fin.getElem_fin, List.getElem_map] at memb
      specialize h hd tl[idx] (by grind)
      exact Multiset.disjoint_left.mp h mema memb
    Â· exact hNd hd

theorem map_fin_cast {n m : Nat} (h : n = m)
    : (Multiset.map (Fin.cast h) Fintype.elems.val)
    = Fintype.elems.val := by subst h; simp

theorem dite_eq_pull_left
    {c a} {f t : _ â A} [Decidable c]
    : ((if h : c then t h else f h) = a) = if v : c then t v = a else f v = a := by
  grind

theorem dite_eq_pull_right
    {c a} {f t : _ â A} [Decidable c]
    : (a = (if h : c then t h else f h)) = if v : c then a = t v else a = f v := by
  grind

theorem dite_and_dite
    {c} {fâ fâ tâ tâ : _ â Prop} [Decidable c]
    : ((if h : c then tâ h else fâ h) â§ if h : c then tâ h else fâ h)
    = if v : c then tâ v â§ tâ v else fâ v â§ fâ v := by
  grind

theorem multiset_map_sum {n : Nat}
    (sel : Fin n â Multiset A)
    (f : A â B)
    : (â x, Multiset.map f (sel x)) = Multiset.map f (â x, sel x) := by
  unfold Finset.sum
  generalize (Finset.univ.val : Multiset (Fin n)) = z
  simp

theorem ms_eq_lift {a b : Multiset A} (eq : a = b) : a.toList.Perm b.toList := 
  eq â¸ List.Perm.refl a.toList

theorem ms_toList_add {a b : Multiset A} : (a + b).toList.Perm (a.toList ++ b.toList) := by
  induction a using Quot.ind; rename_i a
  induction b using Quot.ind; rename_i b
  simp only [Multiset.quot_mk_to_coe'', Multiset.coe_add]
  refine Perm_ofList_toList.symm.trans <| List.Perm.append ?_ ?_
  <;> exact Perm_ofList_toList

theorem ms_sum_toList_Perm
    : (ls : List (Multiset A)) â ls.sum.toList.Perm (ls.map Multiset.toList).flatten
  | [] => by simp
  | hd :: tl => by
    simp only [List.sum_cons, List.map_cons, List.flatten_cons]
    apply ms_toList_add.trans
    refine List.Perm.append (ms_eq_lift rfl) ?_
    exact ms_sum_toList_Perm _

theorem filter_fin_to_map {n m : Nat} (h : n â¤ m)
    : (Multiset.filter (fun x : Fin m â¦ âx < n) Fintype.elems.val)
    = (Multiset.map (Fin.castLE h) Fintype.elems.val) := by
  apply Multiset.ext'_iff.mpr
  intro a
  rw [
    Multiset.count_eq_of_nodup (Multiset.Nodup.filter _ Fintype.elems.nodup),
    Multiset.count_eq_of_nodup (Multiset.Nodup.map (Fin.castLE_injective h) Fintype.elems.nodup)
  ]
  simp [Fintype.complete]
  split <;> rename_i h
  <;> simp only [left_eq_ite_iff, not_exists, one_ne_zero, imp_false, not_forall,
      Decidable.not_not, right_eq_ite_iff, zero_ne_one, imp_false, not_exists]
  Â· use â¨_, hâ©
    simp
  Â· rintro _ rfl
    simp at h

theorem fintype_split
    {n m : Nat}
    : (Fintype.elems.val : Multiset (Fin (n + m)))
    = Multiset.map (Fin.castAdd m) (Fintype.elems.val : Multiset (Fin n))
    + Multiset.map (Fin.cast (Nat.add_comm _ _)) (Multiset.map (Fin.addNat Â· n) Fintype.elems.val)
    := by
  refine Multiset.ext.mpr fun a => ?_
  rw [Multiset.count_eq_of_nodup Fintype.elems.nodup]
  simp only [Finset.mem_val, Fintype.complete, âreduceIte, Multiset.map_map, Function.comp_apply,
    Fin.cast_addNat, Multiset.count_add]
  rw [
    Multiset.count_eq_of_nodup
      <| Multiset.Nodup.map (Fin.castAdd_injective n m) (Fintype.elems.nodup),
    Multiset.count_eq_of_nodup 
      <| Multiset.Nodup.map (Fin.natAdd_injective m n) (Fintype.elems.nodup)
  ]
  simp only [Multiset.mem_map, Finset.mem_val, Fintype.complete, true_and]
  split <;> rename_i h
  Â· rcases h with â¨w, rflâ©
    simp only [Nat.left_eq_add, ite_eq_right_iff, one_ne_zero, imp_false, not_exists]
    intro â¨a, altâ© h
    rcases w with â¨w, wltâ©
    simp only [Fin.natAdd_mk, Fin.castAdd_mk, Fin.mk.injEq] at h
    omega
  Â· split
    Â· rfl
    Â· rename_i h'
      rcases a with â¨a, altâ©
      rw [not_exists] at h' h
      have nh : â x, (h : x < n) â Â¬x = a := fun x h' v => h â¨x, h'â© (v â¸ rfl)
      have nh' : â x, (h : x < m) â Â¬n + x = a := fun x h v => h' â¨x, hâ© (v â¸ rfl)
      clear h h'
      exfalso
      rcases lt_or_ge a n with (h|h)
      Â· exact nh _ h rfl
      Â· obtain â¨a,rflâ© := Nat.exists_eq_add_of_le h
        apply nh' _ _ rfl
        omega

@[simp]
theorem sum_gl?_r : (@Sum.getLeft? A B  â Sum.inr) = (fun _ => none) := rfl
@[simp]
theorem sum_gr?_r : (@Sum.getRight? A B â Sum.inr) = some := rfl
@[simp]
theorem sum_gl?_l : (@Sum.getLeft? A B  â Sum.inl) = some := rfl
@[simp]
theorem sum_gr?_l : (@Sum.getRight? A B â Sum.inl) = (fun _ => none):= rfl

end lemmas

section Ex3

-- I ended up using two definitions and transforming between them.
-- The reasoning for this is I found the easiest way to prove assoc was using both.
structure Ent (A B : Type u) where
  r : List A â B â Prop
  -- We use the same change as we did in Ex2.
  -- Later we do actually benefit from being able to extract a Ï though.
  perm : â {lâ b}, r lâ b â â {lâ}, lâ.Perm lâ â r lâ b

namespace Ent

@[ext]
def ext {E F : Ent A B} (h : â a b, E.r a b â F.r a b) : E = F :=
  match E, F with
  | â¨_, _â©, â¨_, _â© =>
    (mk.injEq _ _ _ _).mpr
    <| funext fun a => funext fun b => propext (h a b)

-- The second definition is much cleaner it is: Multiset A â B â Prop
-- Sadly I did not realise this until too late.
section defn2

def MsRel (x : Ent A B) (ms : Multiset A) (bv : B) : Prop :=
  x.r ms.toList bv

def ofMsRel (R : Multiset A â B â Prop) : Ent A B where
  r ls b := R ls b
  perm {lâ b} R {lâ} lperm := by
    have : Multiset.ofList lâ = Multiset.ofList lâ := Multiset.coe_eq_coe.mpr lperm.symm
    rw [this]
    exact R

theorem msRel_iff_r_toList {l b} {E : Ent A B} : E.r l.toList b = E.MsRel l b := by rfl
theorem msRel_coe_iff_r {l b} {E : Ent A B} : E.r l b = E.MsRel l b := by
  refine propext â¨?_, ?_â© <;> refine fun h => E.perm h ?_
  Â· exact Perm_ofList_toList
  Â· exact Perm_ofList_toList.symm

-- The definition we use is equivilent to this alternative definition.
def equivMsRel : (Ent A B) â (Multiset A â B â Prop) where
  toFun e := MsRel e
  invFun := ofMsRel
  left_inv e := by
    ext a b
    constructor
    <;> rintro h
    <;> apply e.perm h
    <;> apply Multiset.coe_eq_coe.mp
    <;> simp
  right_inv v := funext fun a => funext fun b => by
    simp [ofMsRel, MsRel]

end defn2

-- Relational lifting is exacly as given
abbrev LiftR (R : A â B â Prop) : Ent A B where
  r a b := â w, a = [w] â§ R w b
  perm {l b} := by
    rintro â¨w, rfl, rwbâ©
    simpa

abbrev Ax A : Ent A A := LiftR (Â· = Â·)

-- Composition of Ents will use tree structures pairing the values up through the composition.
-- I do this through using the multiset preimages of functions.
-- Lean did not have these built in so I develop the basic theory needed for them here.

def fin_preimage {A B} [fta : Fintype A] [DecidableEq B]
    (f : A â B) (b : B)
    : Multiset A :=
  fta.elems.val.filter (f Â· = b)

-- I had to develop a theory of fin_preimages to work with them
-- I mainly worked on how fin_preimages compose.
-- I have not put much work into making these proofs readable as they should maybe be in an Apendix.

namespace fin_preimage

variable {A B C : Type _} [fta : Fintype A]

def nodup [DecidableEq B] {f : A â B} {v}
    : (fin_preimage f v).Nodup :=
  Multiset.Nodup.filter _ fta.elems.nodup

-- Composing with bijections was the first part I developed.
-- Later I realised general composition makes this much easier.

@[simp]
theorem comp_bij {b} {f : A â B} {g : B â C} [DecidableEq B] [DecidableEq C] [Fintype B]
    {gInv : C â B}
    (hl : Function.LeftInverse gInv g)
    (hr : Function.RightInverse gInv g)
    : fin_preimage (g â f) b = fin_preimage f (gInv b) := by
  simp [fin_preimage]
  induction fta.elems.val using Quot.ind; rename_i l
  simp only [Multiset.quot_mk_to_coe'', Multiset.filter_coe, Multiset.coe_eq_coe]
  apply List.Perm.of_eq
  induction l
  Â· rfl
  case cons hd tl ih =>
    simp [List.filter_cons, âih]
    split
    <;> split
    <;> simp_all
    <;> rename_i hâ hâ
    Â· apply hâ
      rw [âhâ]
      exact (hl _).symm
    Â· refine hâ <| hr _

@[simp]
theorem comp_bij'
    {b fInv} (f : A â B) (g : B â C) [DecidableEq C] [ftb : Fintype B]
    (hl : Function.LeftInverse fInv f)
    (hr : Function.RightInverse fInv f)
    : fin_preimage (g â f) b = (fin_preimage g b).map fInv := by
  dsimp [fin_preimage]
  have : â (p : A â Prop), DecidablePred p :=
    fun p _ => Classical.propDecidable _
  rw [Multiset.map_filter' _ (Function.LeftInverse.injective hr)]
  have : (Multiset.map fInv ftb.elems.val) = fta.elems.val := by
    refine (Multiset.Nodup.ext ?_ ?_).mpr ?_
    Â· refine (Multiset.nodup_map_iff_of_injective <| Function.LeftInverse.injective hr).mpr
        <| Fintype.elems.nodup
    Â· exact Fintype.elems.nodup
    intro a
    simp only [Multiset.mem_map, Finset.mem_val, Fintype.complete, true_and, iff_true]
    use f a
    exact hl a
  rw [this]
  refine (Multiset.Nodup.ext ?_ ?_).mpr ?_
  any_goals exact Multiset.Nodup.filter _ <| Fintype.elems.nodup
  intro a
  simp only [Multiset.mem_filter, Finset.mem_val, Fintype.complete, true_and]
  constructor
  Â· rintro rfl
    use f a
    exact â¨rfl, hl aâ©
  Â· rintro â¨_, rfl, rflâ©
    rw [hr]

@[simp]
theorem fin_preimage_id {v : A} [DecidableEq A] : (fin_preimage id v) = {v} := by
  simp [fin_preimage, Multiset.filter_eq', Multiset.count_eq_of_nodup fta.elems.nodup, fta.complete]

@[simp]
theorem bij
    {b fInv} (f : A â B) [DecidableEq B] [Fintype B]
    (hl : Function.LeftInverse fInv f)
    (hr : Function.RightInverse fInv f)
    : fin_preimage f b = {fInv b} := calc
  fin_preimage f b
    = fin_preimage (id â f) b       := rfl
  _ = (fin_preimage id b).map fInv  := comp_bij' _ _ hl hr
  _ = Multiset.map fInv {b}         := by rw [fin_preimage_id]
  _ = {fInv b}                      := rfl


@[simp]
theorem unit_inv (f : A â Fin 1) : (fin_preimage f 0) = fta.elems.val := by
  simp only [fin_preimage, Fin.isValue, Multiset.filter_eq_self, Finset.mem_val, fta.complete,
    forall_const]
  intro a; cases f a; omega

theorem eq_unit {f : A â B} [DecidableEq B] {v a}
    (h : fin_preimage f v = {a}) : f a = v := by
  simp [fin_preimage] at h
  rcases fta with â¨â¨ms, ndâ©, compâ©
  change Multiset.filter (fun x â¦ f x = v) ms = {a} at h
  induction ms using Quot.ind; rename_i ms
  simp [List.filter_eq_cons_iff] at h nd comp
  rcases h with â¨_, _, _, _, rfl, _â©
  rfl

theorem exists_sig_iff_unique_valued {f : A â B} [DecidableEq B] {v}
    : (â a, fin_preimage f v = {a}) â â! a, f a = v := by
  have : DecidableEq A := Classical.typeDecidableEq A
  constructor
  Â· rintro â¨w, hâ©
    have := eq_unit h
    refine â¨w, this, fun y => ?_â©
    rintro rfl
    dsimp [fin_preimage] at h
    rcases fta with â¨â¨ms, ndâ©, compâ©
    change Multiset.filter (fun x â¦ f x = _) ms = {w} at h
    induction ms using Quot.ind; rename_i ms
    simp only [Multiset.quot_mk_to_coe'', Multiset.coe_nodup, Finset.mem_mk, Multiset.mem_coe,
      Multiset.filter_coe, Multiset.coe_eq_singleton, List.filter_eq_cons_iff, decide_eq_true_eq,
      this, decide_true, List.filter_eq_nil_iff, true_and] at ms nd comp h
    rcases h with â¨lâ, lâ, rfl, hl, hrâ©
    obtain (h|rfl|h) : y â lâ â¨ y = w â¨ y â lâ := by have := comp y; simp_all
    Â· exact (hl _ h rfl).elim
    Â· rfl
    Â· exact (hr _ h rfl).elim
  Â· rintro â¨a, rfl, uniqâ©
    use a
    rcases fta with â¨â¨ms, ndâ©, compâ©
    dsimp [fin_preimage]
    induction ms using Quot.ind; rename_i ms
    simp only [Multiset.quot_mk_to_coe'', Finset.mem_mk, Multiset.mem_coe, Multiset.coe_nodup,
      Multiset.filter_coe, Multiset.coe_eq_singleton, List.filter_eq_cons_iff, decide_eq_true_eq,
      decide_true, List.filter_eq_nil_iff, true_and] at comp nd uniq â¢
    let idx := ms.idxOf a
    use (ms.take idx), (ms.drop idx.succ)
    rw [
      show a = ms.get (Fin.mk (ms.idxOf a) (List.idxOf_lt_length_of_mem (comp a))) from by simp,
      List.cons_get_drop_succ,
      List.take_append_drop,
      List.get_eq_getElem, List.getElem_idxOf]
    refine â¨rfl, ?tk, ?dpâ©
    <;> intro v h heq
    <;> obtain rfl := uniq _ heq
    <;> dsimp [idx] at h
    <;> clear *-h nd
    <;> induction ms
    any_goals simp only [List.not_mem_nil, not_false_eq_true, List.idxOf_of_notMem, List.length_nil,
      List.take_nil, zero_add, List.drop_nil, List.drop_succ_cons] at h
    all_goals rename_i hd tl ih
    all_goals by_cases h' : hd = v
    any_goals subst h'
    all_goals simp_all

-- Notably you can also conclude they are a bijection iff they have unique preimages.

theorem exists_sig_iff_bijective {f : A â B} [DecidableEq B]
    : (â v, â a, fin_preimage f v = {a}) â Function.Bijective f := by
  conv => lhs; intro v; rw [exists_sig_iff_unique_valued]
  exact (Function.bijective_iff_existsUnique f).symm

-- If you integrate over the entire function space you get the original function.
theorem sum_all
    {f : A â B} [DecidableEq B] [Fintype B]
    : (â x, fin_preimage f x) = fta.elems.val := by
  dsimp [fin_preimage]
  have : DecidableEq A := Classical.typeDecidableEq A
  refine Multiset.ext'_iff.mpr fun a => ?_
  simp only [Multiset.count_eq_of_nodup fta.elems.nodup, Finset.mem_val, fta.complete, âreduceIte]
  refine Multiset.count_eq_one_of_mem ?_ ?comp
  case comp => simp [fta.complete]
  apply nodup_disj
  Â· exact fun a => Multiset.Nodup.filter _ Fintype.elems.nodup
  intro a b h
  apply Multiset.disjoint_left.mpr
  intro v hma hmb
  simp [Fintype.complete] at hma hmb
  exact h <| hma.symm.trans hmb

-- I see how useful this is now in hindsight but sadly I did not come up with this earlier.
-- Slightly silly.
theorem comp
    {v} (f : A â B) (g : B â C) [DecidableEq C] [ftb : Fintype B] [DecidableEq B]
    : fin_preimage (g â f) v
    = ((fin_preimage g v).bind (fin_preimage f Â·)) := by
  have : DecidableEq A := Classical.typeDecidableEq A
  dsimp [fin_preimage]
  apply Multiset.ext.mpr
  intro a
  simp only [Multiset.count_filter, Multiset.count_eq_of_nodup fta.elems.nodup, Finset.mem_val,
    fta.complete, âreduceIte]
  symm
  split <;> rename_i h
  case isFalse => simpa [Fintype.complete]
  rw [Multiset.count_eq_of_nodup]
  Â· simp [h, Fintype.complete]
  simp only [Multiset.nodup_bind, Multiset.mem_filter, Finset.mem_val, Fintype.complete, true_and]
  constructor
  Â· rintro a' _
    exact Multiset.Nodup.filter _ Fintype.elems.nodup
  refine Multiset.Nodup.pairwise ?_ ?nd
  case nd => exact Multiset.Nodup.filter _ Fintype.elems.nodup
  rintro a - b - neq
  apply Multiset.disjoint_left.mpr ?_
  intro z xmem ymem
  simp only [Multiset.mem_filter, Finset.mem_val, Fintype.complete, true_and] at xmem ymem
  exact neq (xmem.symm.trans ymem)

end fin_preimage

-- Composition was an absolute pain.
-- I went through 4 equivilent definitions before I ended up with these two equivilent definitions.
-- This uses fin_preimages to map up between the lists.

def comp (E : Ent A B) (F : Ent B C) : Ent A C where
  r := fun ls c =>
    â lpart : List B, â f : Fin ls.length â Fin lpart.length,
      F.r lpart c
      â§ â v : Fin lpart.length,
        E.MsRel (fin_preimage f v |>.map (ls[Â·])) lpart[v]
  -- The question also contains:
  -- > Remember to argue that if E â A* Ã B is an entailment from A to B and
  -- > F â B* Ã C is an entailment from ðµ to ð¶ then their composition
  -- > F â E â A* Ã C is an entailment from A to C.
  -- Perm proves this
  perm := by
    rintro lâ b â¨lpart, fMap, fHolds, mappingâ© lâ perm
    obtain â¨â¨s, vâ©, rflâ© := List.Perm_apply_sig perm
    have p := (@List.apply_sig_length A lâ â¨s, vâ©)
    refine â¨lpart, (fMap â s) â (Fin.cast p), fHolds, ?_â©
    have â¨invC, hlC, hrCâ© :=
      Function.bijective_iff_has_inverse.mp <| (bij_f_cast (p := p))
    obtain rfl : invC = Fin.cast p.symm := by 
      clear *-hlC hrC
      funext v
      rw [âhrC v, hlC, Fin.cast_trans, Fin.cast_eq_self]
    have â¨invS, hlS, hrSâ© := Function.bijective_iff_has_inverse.mp v
    intro v'
    rw [fin_preimage.comp_bij' _ _ hlC hrC, fin_preimage.comp_bij' _ _ hlS hrS]
    simp only [List.apply_sig, Multiset.map_map, Function.comp_apply, Fin.getElem_fin,
      List.getElem_ofFn, Fin.coe_cast, Fin.eta]
    conv => lhs; lhs; intro x; rw [hrS x]
    exact mapping v'

-- Type \circledast
infixr:100 " â " => comp

-- The alternative, much cleaner definition is as follows:
-- We construct these objects pairing up the data and proofs we need
structure CompObj (E : Multiset A â B â Prop) where
  la : Multiset A
  b : B
  r : E la b

-- Then composition simply states the existance of these objects.
-- Trivially this is an entailement thanks to the construction of the relational definition.
def comp'
    (E : Multiset A â B â Prop)
    (F : Multiset B â C â Prop)
    (ls : Multiset A)
    (c : C) : Prop :=
  â lpart : Multiset (CompObj E),
    F (lpart.map CompObj.b) c
    â§ ls = (lpart.map CompObj.la).sum

section comp_equiv_comp'

-- To prove the definitions are equivilent we need to construct this function.
-- It simply is zero when mapping to the head,
-- and otherwise recurses in the expected way.
-- Note how silly the transfomration to the next value is.
-- This causes us a massive headache in the next section.
noncomputable def compObj_mapper {E : Multiset A â B â Prop}
    : (lpart : List (CompObj E))
    â Fin (List.map (Multiset.toList â CompObj.la) lpart).flatten.length
    â Fin (List.map CompObj.b lpart).length
  | [] , v => v.elim0
  | hd :: tl, v =>
    if h : v < hd.la.card then
      â¨0, by simpâ©
    else
      Fin.succ
        <| compObj_mapper tl
        <| v.cast (by simp [Nat.add_comm])
        |>.subNat hd.la.card (by rw [Fin.coe_cast]; exact Nat.le_of_not_lt h)

-- This proof is absolutely silly.
-- On paper it would be much much cleaner.
-- Below is a basic scetch of how it would look:
/-
  RTP: (fin_preimage (compObj_mapper lpart) v).map
          (List.map (Multiset.toList â CompObj.la) lpart).flatten.get
           = lpart[v].la

  We observe that the preimage at each index forms a contigous run of indicies.
  We observe that the indicies included in this run are of the size of an entire sublist.

  Proceed by induction on lpart
  Â· Case lpart = []
    Exfalso. If the list is empty, we cannot have an index into.
  Â· Case lpart = hd :: tl
    Proceed by cases on v
    Â· Case v = 0
      Expand the definitions and expand them.
      We are now RTP: [0, 1, â¯, n].map [hdâ, hdâ, â¯, hdâ, â¯].get = hd.la,
      and we are done.
    Â· Case v = n + 1
      Assume without loss of generality that the size of the size of hd is k,
      Since the definition will iterate through the entire head we are now,
      RTP: (fin_preimage (compObj_mapper tl) n)
              .map (Â· + k)
              .map ([hdâ, hdâ, â¯, hdâ, â¯, (tl)].get = hd.la .
      We can now observe we will never be able to access the k.
      This means we are actually,
      RTP: (fin_preimage (compObj_mapper tl) n).map ([â¯, (tl)].get = hd.la .
      Which follows from the inductive hypothesis.
-/
theorem compObj_mapper.fin_preimage_eq
    {E : Multiset A â B â Prop}
    : (lpart : List (CompObj E))
    â (v : Fin (List.map CompObj.b lpart).length)
    â Multiset.map
        (List.map (Multiset.toList â CompObj.la) lpart).flatten.get
          (fin_preimage (compObj_mapper lpart) v) =
      lpart[v].la
  | [], v => v.elim0
  | hd :: tl, â¨0, _â© => by
    have : DecidableEq A := Classical.typeDecidableEq A
    simp only [fin_preimage, List.map_cons, List.length_cons, compObj_mapper, Function.comp_apply,
      List.flatten_cons, Fin.zero_eta, dite_eq_left_iff, not_lt, Fin.succ_ne_zero, imp_false,
      not_le, List.get_eq_getElem, Fin.getElem_fin, Fin.coe_ofNat_eq_mod, List.length_map,
      Nat.zero_mod, List.getElem_cons_zero]
    rw [filter_fin_to_map (by simp)]
    simp only [Multiset.map_map, Function.comp_apply, Fin.coe_castLE, Multiset.length_toList,
      Fin.is_lt, List.getElem_append_left]
    change Multiset.map (hd.la.toList.get â Fin.cast (by simp)) _ = _
    rw [âMultiset.map_map, map_fin_cast, multiset_map_all]
    exact Multiset.coe_toList hd.la
  | hd :: tl, â¨n+1, hâ© => by
    have : DecidableEq A := Classical.typeDecidableEq A
    symm
    apply (compObj_mapper.fin_preimage_eq tl â¨n, (by simp_all)â©).symm.trans
    apply Multiset.ext.mpr
    intro a
    simp only [fin_preimage, List.get_eq_getElem, Multiset.count_map, Multiset.filter_filter,
      List.map_cons, List.length_cons, Function.comp_apply, List.flatten_cons]
    conv =>
      rhs; rhs; lhs; intro v
      Â· rw [List.getElem_append]
        simp only [Multiset.length_toList, compObj_mapper, List.map_cons, Function.comp_apply,
          List.flatten_cons, List.length_cons, Fin.zero_eta]
        rw [dite_eq_pull_left, dite_eq_pull_right, dite_and_dite]
        simp only [Fin.zero_eq_mk, Nat.add_eq_zero, one_ne_zero, and_false, Fin.succ, Fin.mk.injEq,
          Nat.add_right_cancel_iff, dite_then_false, not_lt]
    conv =>
      rhs; rhs;
      rw [
        âMultiset.map_id Fintype.elems.val,
        âfin_cast_id List.length_append.symm,
        âMultiset.map_map,
        map_fin_cast,
        fintype_split
      ]
    simp only [Multiset.map_map, Function.comp_apply, Fin.cast_addNat, Multiset.map_add,
      Multiset.filter_add, Multiset.card_add]
    conv =>
      rhs;lhs
      rw [Multiset.filter_map]
      simp only [Function.comp_apply, Fin.coe_cast, Fin.coe_castAdd, Fin.cast_trans,
        Multiset.card_map]
      arg 1; lhs; intro x;
      rw! [show (hd.la.card â¤ x.val) = False from (by 
        simp only [eq_iff_iff, iff_false, not_le]
        rw [âMultiset.length_toList]
        exact x.isLt
      )]
      simp only [IsEmpty.exists_iff]
    simp only [Multiset.filter_false, Multiset.card_zero, Multiset.filter_map, Function.comp_apply,
      Fin.coe_cast, Fin.coe_natAdd, Multiset.length_toList, add_tsub_cancel_left, Fin.cast_trans,
      le_add_iff_nonneg_right, zero_le, exists_true_left, Multiset.card_map, zero_add]
    conv =>
      rhs; arg 1; lhs
      Â· intro x; rhs;
        rw [Fin.val_inj (b := â¨n, Nat.succ_lt_succ_iff.mp hâ©)]
        lhs; rhs
        unfold Fin.subNat Fin.cast Fin.addNat
        simp

theorem comp_iff_comp'
    (E : Ent A B) (F : Ent B C)
    : comp E F = equivMsRel.invFun (comp' (equivMsRel.toFun E) (equivMsRel.toFun F)) := by
  ext a b
  dsimp only [equivMsRel, ofMsRel, comp, comp']
  have : DecidableEq A := Classical.typeDecidableEq A
  constructor
  Â· rintro â¨lpart, fmap, hl, hrâ©
    use Multiset.ofList (List.ofFn (fun v => {
      la := Multiset.map (a[Â·]) (fin_preimage fmap v)
      b := lpart[v]
      r := hr v
      : CompObj _ }))
    constructor
    Â· simp only [Fin.getElem_fin, Multiset.map_coe, List.map_ofFn]
      unfold Function.comp
      simp only [MsRel, List.ofFn_getElem]
      exact F.perm hl Perm_ofList_toList
    Â· refine Multiset.ext.mpr fun v => ?_
      simp only [Multiset.coe_count, Fin.getElem_fin, Multiset.map_coe, List.map_ofFn,
        Multiset.sum_coe, List.sum_ofFn, Function.comp_apply, Multiset.count_sum']
      calc
        List.count v a
          = Multiset.count v âa                             := (Multiset.coe_count v a).symm
        _ = Multiset.count v (Multiset.map a.get Fintype.elems.val)
                                                            := by rw [multiset_map_all]
        _ = Multiset.count v (Multiset.map a.get (â x, fin_preimage fmap x))
                                                            := by rw [fin_preimage.sum_all]
        _ = Multiset.count v (â x, Multiset.map a.get (fin_preimage fmap x))
                                                            := by rw [multiset_map_sum]
        _ = â x, Multiset.count v (Multiset.map a.get (fin_preimage fmap x))
                                                            := by rw [âMultiset.count_sum']
  Â· rintro â¨lpart, hl, hrâ©
    induction lpart using Quot.ind; rename_i lpart
    simp only [MsRel, Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.sum_coe] at hl hr

    have := calc
        List.Perm a _                                       := Perm_ofList_toList
        List.Perm _ (List.map CompObj.la lpart).sum.toList  := by rw [hr]
        List.Perm _ (List.map Multiset.toList (List.map CompObj.la lpart)).flatten
                                                            := ms_sum_toList_Perm _
        List.Perm _ (List.map (Multiset.toList â CompObj.la) lpart).flatten
                                                            := by rw [âList.map_map]
    clear hr
    -- By doing this equiality elimination my proof state goes slighly nuclear.
    -- Had I had more time I would have cleaned it up
    obtain â¨â¨s, bijSâ©, rflâ© := List.Perm_apply_sig this.symm
    have â¨si, sil, sirâ© := Function.bijective_iff_has_inverse.mp bijS
    refine â¨
      _,
      (compObj_mapper _ â s) â Fin.cast List.apply_sig_length, --compObj_mapper _ â Fin.cast hACast,
      F.perm hl (List.Perm.symm Perm_ofList_toList),
      fun v => ?_
    â©
    rw [fin_preimage.comp_bij' (Fin.cast _) _ (fin_cast_linv _) (fin_cast_rinv _)]
    rw [fin_preimage.comp_bij' _ _ sil sir]
    simp only [List.apply_sig, Multiset.map_map, Function.comp_apply, List.length_flatten,
      List.map_map, List.get_eq_getElem, Fin.getElem_fin, List.getElem_ofFn, Fin.cast_mk,
      Fin.coe_cast, Fin.eta, List.getElem_map]
    conv => lhs; lhs; intro v; arg 2; rw [sir v]
    change E.MsRel (Multiset.map (List.get _) _) _
    rw [compObj_mapper.fin_preimage_eq]
    exact lpart[v].r

end comp_equiv_comp'

-- Comp respects relations in the way which is asked for.
theorem comp_respects_comp
    (R : A â B â Prop)
    (S : B â C â Prop)
    : LiftR (Relation.Comp R S) = LiftR R â LiftR S := by
  ext a b
  simp only [Relation.Comp, comp, LiftR, Fin.getElem_fin, exists_and_left]
  constructor
  Â· rintro â¨w, rfl, w', r, sâ©
    refine â¨[w'], â¨_, rfl, sâ©, id, fun | â¨0, _â© => â¨w, ?_, râ©â©
    simp
  Â· rintro â¨_, â¨w, rfl, swbâ©, â¨f, hâ©â©
    specialize h â¨0, Nat.zero_lt_succ [].lengthâ©
    simp only [MsRel, List.length_cons, List.length_nil, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
      fin_preimage.unit_inv, Multiset.toList_eq_singleton_iff, Multiset.map_eq_singleton,
      Finset.val_eq_singleton_iff, List.getElem_cons_zero, exists_exists_and_eq_and] at h
    rcases h with â¨w', heq, hrâ©
    obtain â¨wa, rflâ© :=
      have : a.length = 1 := by
        have := Fintype.complete (Î± := Fin a.length)
        rw [heq] at this
        simp only [Finset.mem_singleton] at this
        clear *-this
        rcases a with (_|â¨hd, (_|â¨hd2,tlâ©)â©)
        Â· exact w'.elim0
        Â· rfl
        Â· have := (this â¨0, by simpâ©).trans (this â¨1, by simpâ©).symm
          simp at this
      List.length_eq_one_iff.mp this
    simp only [List.length_cons, List.length_nil, Nat.reduceAdd, Fin.val_eq_zero,
      List.getElem_cons_zero] at hr
    refine â¨wa, rfl, _, hr, swbâ©

section ent_cat

-- Now we move on to prove that entailements form a category.

theorem comp_Ax (E : Ent A B) : E â Ax B = E := by
  -- To conclude they are equal,
  -- we are RTP (E â Ax B).r a b â E.r a b
  ext a b; constructor
  Â· -- To begin we expand our assumptions
    rintro â¨lperm, f, â¨w, rfl, rflâ©, hrâ©

    specialize hr â¨0, by simpâ©; dsimp at hr
    -- Now we have that
    change E.MsRel (Multiset.map a.get (fin_preimage f _)) w at hr

    -- By rewriting using fin_preimage.unit_inv
    simp only [List.length_cons, List.length_nil, Nat.reduceAdd, fin_preimage.unit_inv] at hr
    -- it then becomes:
    change E.MsRel (Multiset.map a.get Fintype.elems.val) w at hr

    -- From here it is quite easy
    rw [multiset_map_all] at hr
    exact E.msRel_coe_iff_r.mpr hr
  Â· intro (h : E.r a b)
    have g := fun (_ : Fin a.length) => (â¨0, by simpâ© : Fin 1)
    refine â¨[b], g, â¨_, rfl, rflâ©, fun â¨0, _â© => ?_â©

    -- The other proof very similarly but reversed.
    -- We start with
    change E.MsRel (Multiset.map _ (fin_preimage g 0)) b
    -- Then applying the same rewrites
    rw [fin_preimage.unit_inv g]
    -- we are left with
    change E.MsRel (Multiset.map a.get Fintype.elems.val) b

    -- which we close in teh same way
    rw [multiset_map_all]
    exact msRel_coe_iff_r.mp h

-- This is cleaner in the other definition but annoyingly this is the one I got in the end
theorem Ax_comp (E : Ent A B) : Ax A â E = E := by
  ext a b; constructor
  Â· -- To begin we have,
    rintro â¨lperm, f, (r : E.r lperm b), hâ©
    -- using r it suffices to prove: lperm.Perm a
    apply E.perm r

    simp only [MsRel, Fin.getElem_fin, Multiset.toList_eq_singleton_iff, Multiset.map_eq_singleton,
      exists_eq_right] at h
    -- Because of lean nonsense we clean up h a bit,
    -- this gives us:
    -- h : â (v : Fin lperm.length), â a_1, fin_preimage f v = {a_1} â§ a[âa_1] = lperm[âv]

    -- We can use fact that the finset is unique to construct that f is a bijection
    have fBij : Function.Bijective f := fin_preimage.exists_sig_iff_bijective.mp
      fun v => â¨Classical.choose (h v), (Classical.choose_spec (h v)).1â©
    -- and consequencely has an inverse fi
    have â¨fi, hl, hrâ© := Function.bijective_iff_has_inverse.mp fBij

    -- We use the other side of h to show that,
    have hEq : â (v : Fin lperm.length), a[fi v] = lperm[v] := fun v => by
      obtain â¨_, hFinset, hEqâ© := h v
      rw [fin_preimage.bij _ hl hr, Multiset.singleton_inj] at hFinset
      subst hFinset
      exact hEq

    clear h hr

    -- Since f is a bijection, natruarlly their lengths are equal.
    have hlEq : a.length = lperm.length := by
      have : (FinEnum.card (Fin a.length))
           = (FinEnum.ofEquiv (Fin a.length) ((Equiv.ofBijective f fBij).symm)).card
        := rfl
      simpa using this

    -- To show something is a permutation of another,
    -- it suffices to show that there exists some Ï equalizing them.
    apply List.ex_sigma_perm
    -- We pick f as our bijection
    -- (the noise here comes from f not currently type checking).
    refine â¨â¨f â Fin.cast hlEq.symm, Function.Bijective.comp fBij bij_f_castâ©, ?_â©
    refine List.ext_getElem (List.apply_sig_length.trans hlEq.symm) fun i hâ hâ => ?_

    -- We now need to show that applying the Ï gives us the orignal list.
    -- I changed this to be done pointwise as it is cleaner
    simp only [List.apply_sig, List.getElem_ofFn, Function.comp_apply, Fin.cast_mk,
      List.get_eq_getElem]
    calc
      lperm[f â¨i, hââ©]
        = a[fi (f â¨i, hââ©)] := (hEq (f â¨i, hââ©)).symm
      _ = a[Fin.mk i hâ] := by rw [hl â¨i, hââ©]
  Â· intro h
    use a, id
    -- The other direction holds trivially in this representation.
    simp [h, MsRel]

section assoc

-- Showing associativity would be really really hard with either of our definitions.
-- Using both simplifies this process quite dramatically making the proof supprisingly beutiful.
-- This is just like the meme of Homer looking nice and slim with his fat tied behind his back.
-- All of the pain that would go into these proofs,
-- has now gone into showing the definitions are equivilent.

theorem comp'_assoc' {W X Y Z} (f : Multiset W â X â Prop) g (h : Multiset Y â Z â Prop)
    {a b} : comp' (comp' f g) h a b â comp' f (comp' g h) a b := by
  rintro â¨lwp, hr, rflâ©

  -- Using this defn, we need to fist construct a multiset,
  -- then show it is related in the needed ways.
  -- We pick the multiset using Classical.choice to get the multiset form the deeper composition.
  -- We then have to show the structure holds in the way we expect.

  refine â¨(lwp.map (fun v => Classical.choose (CompObj.r v))).sum, ?_, ?_â©
  Â· -- It holds for the underlaying composition practically by definition
    refine â¨lwp.map (fun v => CompObj.mk _ _ (Classical.choose_spec (CompObj.r v)).left), ?_, ?_â©
    Â· rw [Multiset.map_map]
      exact hr
    Â· simp [Multiset.map_map]
  Â· simp only [multiset_map_some, Multiset.map_map, Function.comp_apply]
    -- To show the sums are equal is a quite mechanical task but can be done using induction.
    clear *-
    induction lwp using Quot.ind; rename_i lwp
    induction lwp
    Â· simp
    case cons hd tl ih =>
      simp only [Multiset.quot_mk_to_coe'', Multiset.map_coe, Multiset.sum_coe, List.map_cons,
        List.sum_cons, Multiset.sum_add] at ih â¢
      rw [â(Classical.choose_spec hd.r).right, âih]

theorem comp_assoc' {W X Y Z} (f : Ent W X) (g : Ent X Y) (h : Ent Y Z)
    {a b} : (f â g â h).r a b â ((f â g) â h).r a b := by
  rintro â¨lx, fMap, â¨lym, gMap, hh, hhAllâ©, hyAllâ©
  -- To go the other direction, it follows from function composition.
  refine â¨lym, gMap â fMap, hh, fun iLym => ?_â©
  specialize hhAll iLym

  -- Thoguh this leaves us to show an insane expression
  change equivMsRel.toFun (f â g) (Multiset.map a.get (fin_preimage (gMap â fMap) iLym)) lym[iLym]
  -- We translate into the other definition
  rw [comp_iff_comp', equivMsRel.right_inv]
  -- Now we just need to construct the multiset and we are done
  change comp' f.MsRel g.MsRel (Multiset.map a.get (fin_preimage (gMap â fMap) iLym)) lym[iLym]

  -- We map the finset and use our function from the other definition to give us the proof we need.
  refine â¨(fin_preimage gMap iLym).map fun v => CompObj.mk _ _ (hyAll v), ?_, ?_â©
  -- From this the two properties we need fall out basically by definition.
  Â· simp only [Fin.getElem_fin, Multiset.map_map, Function.comp_apply]
    exact hhAll
  Â· rw [fin_preimage.comp]
    simp
    change _ = (fin_preimage gMap iLym).bind _
    rw [Multiset.map_bind]

theorem comp_assoc {W X Y Z} (f : Ent W X) (g : Ent X Y) (h : Ent Y Z)
    : (f â g) â h = f â g â h := by
  ext a b
  constructor
  Â· simp only [comp_iff_comp', Equiv.toFun_as_coe, Equiv.invFun_as_coe, Equiv.apply_symm_apply]
    exact comp'_assoc' _ _ _
  Â· exact comp_assoc' _ _ _

end assoc

end ent_cat

end Ent

-- Now we construct the category.
@[pp_with_univ]
structure EType where
  ofType ::
  toType : Type u

instance : Category EType where
  Hom   a b := Ent a.toType b.toType
  comp  := Ent.comp
  id X := Ent.Ax X.toType
  id_comp := Ent.Ax_comp
  comp_id := Ent.comp_Ax
  assoc   := Ent.comp_assoc

namespace EType
open EType Ent

-- We can show really easility that â is terminal
instance isTermEmpt : Limits.IsTerminal (ofType PEmpty) :=
  .ofUniqueHom (fun _Y => {
    -- This is the case because we can only have the empty relation,
    r _h _l := False
    perm {_l _b} f := f.elim
  })
  -- and the empty relation is nececerrily unique.
  fun _x _m => Ent.ext fun _a b => b.elim

instance : Limits.HasTerminal EType := isTermEmpt.hasTerminal

-- The category cannot have an initial.
def not_initial (v : Limits.HasInitial EType.{u}) : False :=
  -- To do this construct two morhpsim from the terminal object into {}
  let alwaysTrue : â¥_ EType.{u} â¶ ofType PUnit := {
    r _ _ := True
    perm _ _ _ := .intro
  }
  let alwaysFalse : â¥_ EType.{u} â¶ ofType PUnit := {
    r _ _ := False
    perm := False.elim
  }

  -- Since the morphisms must be unique
  have uniq := ofType PUnit |> Limits.uniqueFromInitial |>.uniq
  -- We can show
  have : alwaysTrue = alwaysFalse := (uniq alwaysTrue).trans (uniq alwaysFalse).symm

  -- From this we can get false
  (Ent.ext_iff.mp this [] .unit).mp True.intro

-- It turns out that disjoint union is the product.
-- In hindsight, I see since the logic is linear,
-- the product will be With from linear logic.
-- I ended up using this as a good hint later on.

def fst (A B : EType.{u}) : ofType (A.toType â B.toType) â¶ A where
  r a b := a = [.inl b]
  perm := by
    rintro _ b' rfl a perm
    obtain rfl := List.singleton_perm.mp perm
    rfl

def snd (A B : EType.{u}) : ofType (A.toType â B.toType) â¶ B where
  r a b := a = [.inr b]
  perm := by
    rintro _ b' rfl a perm
    obtain rfl := List.singleton_perm.mp perm
    rfl

def lift
    (A B : EType.{u})
    {T : EType.{u}}
    (f : T â¶ A) (s : T â¶ B) : T â¶ { toType := A.toType â B.toType } where
  r tl := fun
    | .inl v => f.r tl v
    | .inr v => s.r tl v
  perm {_ b} h _ perm := match b with
    | .inl _ => f.perm h perm
    | .inr _ => s.perm h perm

-- We will use ofUniqueHom to show that fst, snd, and (Â· â Â·) for the product.
/--
info: def CategoryTheory.Limits.IsBinaryProduct.ofUniqueHom.{u, u_1} : {ð : Type u} â
  [inst : Category.{u_1, u} ð] â
    {X Y P : ð} â
      {fst : P â¶ X} â
        {snd : P â¶ Y} â
          (lift : {T : ð} â (T â¶ X) â (T â¶ Y) â (T â¶ P)) â
            (â {T : ð} (f : T â¶ X) (g : T â¶ Y), lift f g â« fst = f) â
              (â {T : ð} (f : T â¶ X) (g : T â¶ Y), lift f g â« snd = g) â
                (â {T : ð} (f : T â¶ X) (g : T â¶ Y) (m : T â¶ P), m â« fst = f â m â« snd = g â m = lift f g) â
                  Limits.IsBinaryProduct fst snd :=
fun {ð} [Category.{u_1, u} ð] {X Y P} {fst} {snd} lift hlâ hlâ uniq â¦
  Limits.BinaryFan.IsLimit.mk (Limits.BinaryFan.mk fst snd) (fun {T} â¦ lift) â¯ â¯ â¯
-/
#guard_msgs in
#print Limits.IsBinaryProduct.ofUniqueHom

instance isBiProdSum (A B : EType.{u}) : Limits.IsBinaryProduct (fst A B) (snd A B) :=
  .ofUniqueHom (lift A B)
    (fun {T} f g => by
      -- We need to show lift f g â« A.fst B = f
      -- This proof is very similar to the proofs for comp_Ax.
      refine ext fun a b => ?_
      dsimp [CategoryStruct.comp, comp, MsRel]
      constructor
      Â· rintro â¨lpart, fMap, rfl, hrâ©
        specialize hr â¨0, by simpâ©

        change (A.lift B f g).r (Multiset.map a.get (fin_preimage fMap _)).toList _ at hr
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd,
          Fin.zero_eta, Fin.isValue, fin_preimage.unit_inv] at hr
        change f.r (Multiset.map a.get Fintype.elems.val).toList b at hr

        rw [multiset_map_all] at hr
        exact f.perm hr Perm_ofList_toList.symm
      Â· intro hr
        refine â¨_, (fun _ => â¨0, by simpâ©), rfl, fun | â¨0, _â© => ?_â©

        simp only [List.getElem_cons_zero, List.length_cons, List.length_nil, Nat.reduceAdd,
          Fin.zero_eta, Fin.isValue, fin_preimage.unit_inv]
        change f.r (Multiset.map a.get Fintype.elems.val).toList b

        rw [multiset_map_all]
        exact f.perm hr Perm_ofList_toList)
    (fun {T} f g => by
      -- This proof is virtually idendical to the one above except f and g are swapped.
      refine ext fun a b => ?_
      dsimp [CategoryStruct.comp, comp, MsRel]
      constructor
      Â· rintro â¨lpart, fMap, rfl, hrâ©
        specialize hr â¨0, by simpâ©

        change (A.lift B f g).r (Multiset.map a.get (fin_preimage fMap _)).toList _ at hr
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd,
          Fin.zero_eta, Fin.isValue, fin_preimage.unit_inv] at hr
        change g.r (Multiset.map a.get Fintype.elems.val).toList b at hr

        rw [multiset_map_all] at hr
        exact g.perm hr Perm_ofList_toList.symm
      Â· intro hr
        refine â¨_, (fun _ => â¨0, by simpâ©), rfl, fun | â¨0, _â© => ?_â©

        simp only [List.getElem_cons_zero, List.length_cons, List.length_nil, Nat.reduceAdd,
          Fin.zero_eta, Fin.isValue, fin_preimage.unit_inv]
        change g.r (Multiset.map a.get Fintype.elems.val).toList b

        rw [multiset_map_all]
        exact g.perm hr Perm_ofList_toList)
    fun {T} f s t => by
      rintro rfl rfl
      -- Now we need to show it is unique
      -- RTP: t = lift (t â« A.fst B) (t â« A.snd B)
      refine ext fun | a, .inl b => ?il | a, .inr b => ?ir
      <;> dsimp [CategoryStruct.comp, Ent.comp, fst, snd, MsRel]
      <;> constructor
      -- These proofs are virtually identical to the ones above.
      case il.mp =>
        intro h
        refine â¨_, fun _ => â¨0, by simpâ©, rfl, fun | â¨0, _â© => ?_â©
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
          fin_preimage.unit_inv, List.getElem_cons_zero]
        change t.r (Multiset.map a.get Fintype.elems.val).toList _
        rw [multiset_map_all]
        exact t.perm h Perm_ofList_toList
      case ir.mp =>
        intro h
        refine â¨_, fun _ => â¨0, by simpâ©, rfl, fun | â¨0, _â© => ?_â©
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
          fin_preimage.unit_inv, List.getElem_cons_zero]
        change t.r (Multiset.map a.get Fintype.elems.val).toList _
        rw [multiset_map_all]
        exact t.perm h Perm_ofList_toList

      case il.mpr =>
        rintro â¨_, f, rfl, faâ©
        specialize fa â¨0, by simpâ©
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
          fin_preimage.unit_inv, List.getElem_cons_zero] at fa
        change t.r (Multiset.map a.get Fintype.elems.val).toList _ at fa
        rw [multiset_map_all] at fa
        apply t.perm fa Perm_ofList_toList.symm
      case ir.mpr =>
        rintro â¨_, f, rfl, faâ©
        specialize fa â¨0, by simpâ©
        simp only [List.length_cons, List.length_nil, Nat.reduceAdd, Fin.zero_eta, Fin.isValue,
          fin_preimage.unit_inv, List.getElem_cons_zero] at fa
        change t.r (Multiset.map a.get Fintype.elems.val).toList _ at fa
        rw [multiset_map_all] at fa
        apply t.perm fa Perm_ofList_toList.symm

instance (A B : EType) : Limits.HasBinaryProduct A B :=
  Limits.IsBinaryProduct.hasBinaryProduct _ _ (isBiProdSum  _ _)
instance : Limits.HasBinaryProducts EType :=
  Limits.hasBinaryProducts_of_hasLimit_pair _

-- There are exacly two entailements from PEmpty to PUnit.
noncomputable def unitRel_iso_bool : (Multiset PEmpty â PUnit â Prop) â Bool where
  toFun v :=
    have : Decidable (v â PUnit.unit) := Classical.propDecidable (v â PUnit.unit)
    if v {} .unit then .true
    else .false
  invFun := fun
    | .true => fun _ _ => True
    | .false => fun _ _ => False

  left_inv v := funext fun a => funext fun | .unit => (by
    obtain rfl : a = 0 := Subsingleton.eq_zero a
    dsimp
    split
    <;> simpa)
  right_inv := fun | .true | .false => by simp

open Limits in
theorem noBProd (hCp : HasBinaryCoproducts EType.{u}) : False := by
  -- We begin by showing that,
  -- if binary coproducts exist,
  -- then there are 4 morphisms from â â¨¿ â â¶ {*}
  have equiv := calc
    (Multiset (ofType PEmpty â¨¿ ofType PEmpty).toType â Bool)
      â (Multiset _ Ã PUnit â Prop) := .arrowCongr (Equiv.prodPUnit _).symm Equiv.propEquivBool.symm
    _ â (Multiset _ â PUnit â Prop) := .curry _ _ _
    _ â Ent (ofType PEmpty â¨¿ ofType PEmpty).toType PUnit
                                    := equivMsRel.symm
    _ â Ent PEmpty PUnit Ã Ent PEmpty PUnit
                                    := Limits.coprod_homset_equiv (X := ofType PEmpty)
    _ â (Multiset PEmpty â PUnit â Prop) Ã (Multiset PEmpty â PUnit â Prop)
                                    := Equiv.prodCongr equivMsRel equivMsRel
    _ â Bool Ã Bool                 := Equiv.prodCongr unitRel_iso_bool unitRel_iso_bool

  -- We can use this to show that then the set of morhpsims is finite.
  have finF : Finite (Multiset (( ofType PEmpty ) â¨¿ ( ofType PEmpty )).toType â Bool) :=
    Finite.of_equiv _ equiv.symm

  -- We know that that if the multiset is finite, then the source type is empty.
  have setIsEmp : IsEmpty (ofType PEmpty â¨¿ ofType PEmpty).toType
    := multiset_finite <| finite_of_finite_powerset finF

  -- This implies the multiset is unique
  have uniq : Unique (Multiset (ofType PEmpty â¨¿ ofType PEmpty).toType) := by
    infer_instance

  -- Using this we can construct that 2 = 4
  have contr : 2 = 4 := Fintype.card_eq.mpr â¨calc
    Bool
      â (PUnit â Bool)              := .symm (.punitArrowEquiv Bool)
    _ â (Multiset (ofType PEmpty â¨¿ ofType PEmpty).toType â Bool)
                                    := .arrowCongr (Equiv.equivPUnit.{_, u} _).symm (.refl _)
    _ â Bool Ã Bool                 := equivâ©

  -- Thereby contradiction
  omega

/--
info: 'CategoryTheory.EType.noBProd' depends on axioms: [propext, Classical.choice, Quot.sound]
-/
#guard_msgs in
#print axioms noBProd

-- The Lean definition of Exponentiable looks very scary.
-- It involves adjunctions, and some strange typeclass CartesianMonoidalCategory.
-- I did not want to touch this.
-- I have already had to interact with BinaryFans and -Cofans in Limits and Colimits.
-- Thats enough excitement for one examplesheet.
-- Because of this I simply wont be touching this definition.
-- Instead I will be using the definition stated in lectures:
-- > Exponentials exist in ð if â C X Y, ð(C Ã X, Y) â ð(C, Y^X)

/--
info: CategoryTheory.Exponentiable.mk.{v, u} {C : Type u} [Category.{v, u} C] [CartesianMonoidalCategory C] (X : C)
  (exp : C â¥¤ C) (adj : MonoidalCategory.tensorLeft X â£ exp) : Exponentiable X
-/
#guard_msgs in
#check Exponentiable.mk

-- After seeing how â corresponded to with,
-- I tried really hard to construct â¸.
-- The reasoning for why I picked Multiset X Ã Y in the end,
-- was I wanted a cost in X, and a result in Y.

-- Showing the equivilence is really clean using the Multiset representation.

def expon' (C X Y : Type _)
    : (Multiset C â Multiset X Ã Y â Prop)
    â (Multiset (C â X) â Y â Prop) where
  toFun   e l r := e (l.filterMap Sum.getLeft?) â¨l.filterMap Sum.getRight?, râ©
  invFun  e := fun l â¨ms,râ© => e (ms.map Sum.inr + l.map Sum.inl) r
  left_inv e := by
    -- One direction follows trivially
    ext a â¨ms, bâ©
    simp [filterMap_add, Multiset.filterMap_map]
  right_inv e := by
    -- The other direction is slighly harder
    ext v r
    suffices eq : (Multiset.filterMap (fun x â¦ Option.map Sum.inr x.getRight?) v +
      Multiset.filterMap (fun x â¦ Option.map Sum.inl x.getLeft?) v) = v by
      simp [Multiset.map_filterMap, eq]
    -- We are RTP that:
    change Multiset.filterMap (fun x â¦ Option.map Sum.inr x.getRight?) v +
        Multiset.filterMap (fun x â¦ Option.map Sum.inl x.getLeft?) v =
      v
    -- On paper this is really easy:
    -- Observe the two conditions are disjoint, and we are done.
    -- Instead fo doing this I was just tired and decided to proof bash it out.
    induction v using Quot.ind; rename_i v
    simp only [Multiset.quot_mk_to_coe'', Multiset.filterMap_coe, Multiset.coe_add,
      Multiset.coe_eq_coe]
    induction v
    Â· rfl
    case cons hd tl ih =>
      cases hd
      case inr => simpa
      simp only [Sum.getRight?_inl, Option.map_none, List.filterMap_cons_none, Sum.getLeft?_inl,
        Option.map_some, Option.some.injEq, List.filterMap_cons_some]
      apply List.perm_middle.trans
      rwa [List.perm_cons]

-- Then for good measure we show it for the alternative definition.

def expon (C X Y : Type _)
    : Ent C (Multiset X Ã Y)
    â Ent (C â X) Y := calc
  Ent C (Multiset X Ã Y)
    â (Multiset C â Multiset X Ã Y â Prop)  := equivMsRel
  _ â (Multiset (C â X) â Y â Prop)         := expon' C X Y
  _ â Ent (C â X) Y                         := equivMsRel.symm

/-- info: 'CategoryTheory.EType.expon' depends on axioms: [propext, Classical.choice, Quot.sound] -/
#guard_msgs in
#print axioms expon

end EType

end Ex3

end CategoryTheory

end Ex3.lean

